const axios = require('axios');
const crypto = require('crypto');
const { channel } = require('diagnostics_channel');
const { version } = require('./package.json');
const fs = require('fs');
const { Console } = require('console');

//const podcastIndexApi = require('podcast-index-api')("UGZJEWXUJARKCBAGPRRF", "EmS3h8yCAWjMMAH5wqEPqUyMKDTDA6tDk5qNPLgn")
async function register({
  registerHook,
  registerSetting,
  getRouter,
  peertubeHelpers,
  settingsManager,
  storageManager,
  registerVideoField,
  registerExternalAuth,
}) {

  registerSetting({
    name: 'lightning-address',
    label: 'Lightning address',
    type: 'input',
    descriptionHTML: 'This is a wallet for both the host split and host donations. Should be keysend compatible so getalby is a good choice',
    private: false
  })
  registerSetting({
    name: 'lightning-split',
    label: 'Requires split for host',
    default: '0',
    type: 'input',
    descriptionHTML: 'This will add a percentage split to any boostagrams or streams sent to videos hosted on this instance',
    private: false
  })
  registerSetting({
    name: 'lightning-tipVerb',
    label: 'Verb to use for tipping',
    type: 'input',
    default: 'Boost',
    descriptionHTML: 'Superchat, Zap, Boostagram, bits, spells, whatever your community would prefer.',
    private: false
  })
  registerSetting({
    name: 'alby-client-id',
    label: 'Alby Api Client ID',
    type: 'input',
    descriptionHTML: 'This is the client ID obtained from Alby. Needed to allow users to authorize payments directly from PeerTube in any browser',
    private: false
  })
  registerSetting({
    name: 'alby-client-secret',
    label: 'Alby API client secret',
    type: 'input-password',
    descriptionHTML: 'The client secret',
    private: true
  })
  registerSetting({
    name: 'boost-bot-account',
    label: 'Boost bot account user name for posting cross app comments',
    type: 'input',
    descriptionHTML: '',
    private: false
  })
  registerSetting({
    name: 'boost-bot-password',
    label: 'Password for boost bot',
    type: 'input-password',
    descriptionHTML: 'Needed to allow boost bot to post cross app comments',
    private: true
  })
  registerSetting({
    name: 'simpletip-token',
    label: 'Simpletip token',
    type: 'input-password',
    descriptionHTML: 'used to authorize connections to the simpletip boost aggregator',
    private: true
  })

  registerSetting({
    name: 'rss-enable',
    default: true,
    label: 'Enable enhanced Podcasting 2.0 configuration',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable enhances podcasting 2.0 namespace configuration via channel managemnt page',
    private: false
  })
  registerSetting({
    name: 'irc-enable',
    default: false,
    label: 'Enable IRC chat for channels',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable IRC chat for every channel. Channels can customize the autogenerated room if they have a preferred room',
    private: false
  })
  registerSetting({
    name: 'legacy-enable',
    default: true,
    label: 'Enable legacy fiat tip services',
    type: 'input-checkbox',
    descriptionHTML: 'This will search support and description fields for various third party tip providers',
    private: false
  })
  registerSetting({
    name: 'keysend-enable',
    default: true,
    label: 'Enable Keysend lightning transactions',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable keysend lightning tips, with boostagram meta data',
    private: false
  })
  registerSetting({
    name: 'lnurl-enable',
    default: true,
    label: 'Enable LNURL lightning wallet transactions',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable LNURL lightning wallet transactions, lacks any metadata and is much more data intensive but supports less advanced lighting wallets',
    private: false
  })
  registerSetting({
    name: 'logon-enable',
    default: false,
    label: 'Enable logging in with alby wallet',
    type: 'input-checkbox',
    descriptionHTML: 'This will allow users to authenticate and create accounts using Alby Wallet credentials',
    private: true
  })
  registerSetting({
    name: 'debug-enable',
    default: false,
    label: 'Enable diagnostic log updates',
    type: 'input-checkbox',
    descriptionHTML: 'This will create more extensive logging of program state data both client and server side for finding and resolving errors ',
    private: false
  })

  var base = await peertubeHelpers.config.getWebserverUrl();
  var serverConfig = await peertubeHelpers.config.getServerConfig();
  var hostName = serverConfig.instance.name;
  console.log("⚡️⚡️ home url",base,hostName);
  let lightningAddress = await settingsManager.getSetting("lightning-address");
  if (!lightningAddress) {
    console.log("⚡️⚡️No wallet configured for system");
  }
  let hostSplit = await settingsManager.getSetting("lightning-split");
  if (!hostSplit) {
    hostSplit = 0;
  } else {
    hostSplit = parseInt(hostSplit);
    if (hostSplit < 0 || hostSplit > 100) {
      console.log("⚡️⚡️⚡️⚡️Invalid value for hostsplit", hostSplit);
      hostSplit = 1;
    }
  }
  let tipVerb = await settingsManager.getSetting('lightning-tipVerb');
  let enableLegacy = await settingsManager.getSetting("legacy-enable");
  let enableKeysend = await settingsManager.getSetting("keysend-enable");
  let enableLnurl = await settingsManager.getSetting("lnurl-enable");
  let enableDebug = await settingsManager.getSetting("debug-enable");
  let enableAlbyAuth = await settingsManager.getSetting("logon-enable");
  let enableRss = await settingsManager.getSetting("rss-enable");
  let enableChat = await settingsManager.getSettings("irc-enable");
  let client_id = await settingsManager.getSetting("alby-client-id");
  let client_secret = await settingsManager.getSetting("alby-client-secret");
  let botAccount = await settingsManager.getSetting("boost-bot-account");
  let botPassword = await settingsManager.getSetting("boost-bot-password");
  let simpletipToken = await settingsManager.getSetting("simpletip-token");
  let botToken;
  if (botAccount && botPassword) {
    try {
      botToken = await getPeerTubeToken(botAccount, botPassword);
    } catch {
      console.log("⚡️⚡️⚡️⚡️ error attempting to log bot on");
    }
  }
  console.log("⚡️⚡️⚡️⚡️ Lightning plugin started", enableDebug);
  if (enableDebug) {
    console.log("⚡️⚡️ server settings loaded", hostName, base, hostSplit, lightningAddress);
  }
  let hostWalletData = {};
  let dirtyHack;
  if (enableKeysend || enableLnurl) {
    if (lightningAddress) {
      hostWalletData.address = lightningAddress;
      hostWalletData.name = lightningAddress;
      if (enableKeysend) {
        let hostKeysendData = await getKeysendInfo(lightningAddress);
        if (!hostKeysendData) {
          console.log("⚡️⚡️⚡️⚡️failed to get system wallet data from provider", lightningAddress);
        } else {
          hostWalletData.keysend = hostKeysendData;
        }
      }
      if ((hostSplit > 0 || hostSplit <= 100) && enableDebug) {
        console.log("⚡️⚡️setting host split to ", hostSplit);
        hostWalletData.split = parseInt(hostSplit);
      }
      hostWalletData.fee = true;
      hostWalletData.name = hostName;
    }
  }
  let invoices = [];
  // Store data associated to this video
  registerHook({
    target: 'action:api.video.updated',
    handler: ({ video, body }) => {
      if (!body.pluginData) return

      const seasonNode = body.pluginData['seasonnode'];
      const seasonName = body.pluginData['seasonname'];
      const episodeNode = body.pluginData['episodenode'];
      const episodeName = body.pluginData['episodename'];
      const chapters = body.pluginData['chapters'];
      const itemTxt = body.pluginData['itemtxt'];

      //if (!value) return
      if (seasonNode) {
        storageManager.storeData('seasonnode-' + video.id, seasonNode)
      }
      if (seasonName) {
        storageManager.storeData('seasonname-' + video.id, seasonName)
      }
      if (episodeNode) {
        storageManager.storeData('episodenode-' + video.id, episodeNode)
      }
      if (episodeName) {
        storageManager.storeData('episodename-' + video.id, episodeName)
      }
      if (chapters) {
        storageManager.storeData('chapters-' + video.id, chapters)
      }
      if (itemTxt) {
        storageManager.storeData('itemtxt-' + video.id, itemTxt)
      }
      return;
    }
  })

  // Add your custom value to the video, so the client autofill your field using the previously stored value
  registerHook({
    target: 'filter:api.video.get.result',
    handler: async (video) => {
      if (!video) return video
      if (!video.pluginData) video.pluginData = {}

      const seasonNode = await storageManager.getData('seasonnode-' + video.id)
      video.pluginData["seasonnode"] = seasonNode;
      const seasonName = await storageManager.getData('seasonname-' + video.id)
      video.pluginData["seasonname"] = seasonName;
      const episodeNode = await storageManager.getData('episodenode-' + video.id)
      video.pluginData["episodenode"] = episodeNode;
      const episodeName = await storageManager.getData('episodename-' + video.id)
      video.pluginData["episodename"] = episodeName;
      const chapters = await storageManager.getData('chapters-' + video.id)
      video.pluginData["chapters"] = chapters;
      const itemTxt = await storageManager.getData('itemtxt-' + video.id)
      video.pluginData["itemtxt"] = itemTxt;
      return video
    }
  })
  registerHook({
    target: 'filter:feed.podcast.channel.create-custom-tags.result',
    handler: async (result, params) => {
      // { video: VideoChannelModel }
      const { videoChannel } = params
      //dirtyHack = params;
      //console.log("⚡️⚡️⚡️⚡️ initial channel values ⚡️⚡️⚡️⚡️",params.videoChannel.dataValues.Actor.dataValues.Banners,params.videoChannel.dataValues.Actor.dataValues.Avatars, params);
      console.log("⚡️⚡️⚡️⚡️ initial channel values ⚡️⚡️⚡️⚡️");
      var channel = params.videoChannel.dataValues.Actor.dataValues.preferredUsername;
      var storedSplitData = await getSavedSplit(channel);
      var blocks = []
      if (storedSplitData) {
        for (var split of storedSplitData) {
          let newBlock = {};
          newBlock.name = split.name;
          newBlock.type = "node";
          newBlock.split = split.split;
          if (split.fee) {
            newBlock.fee = split.fee;
          }
          newBlock.address = split.keysend.pubkey;
          if (split.keysend.customData[0] && split.keysend.customData[0].customKey) {
            newBlock.customKey = split.keysend.customData[0].customKey;
            newBlock.customValue = split.keysend.customData[0].customValue;
          }
          blockWrap = {};
          blockWrap.name = "podcast:valueRecipient"
          blockWrap.attributes = newBlock
          blocks.push(blockWrap);
        }
      }
      if (blocks.length < 1) {
        return result;
      }
      let podreturn = [
        {
          name: "podcast:value",
          attributes: {
            "type": "lightning",
            "method": "keysend",
            "suggested": "0.00000005000"
          },
          value: blocks,
        }
      ];
      return result.concat(podreturn)
    }
  })
  // For item level value tags
  registerHook({
    target: 'filter:feed.podcast.video.create-custom-tags.result',
    handler: async (result, params) => {
      // { video: VideoModel, liveItem: boolean }
      const { video, liveItem } = params
      //console.log("⚡️⚡️⚡️⚡️ initial video values ⚡️⚡️⚡️⚡️",result,params,params.video);
      if (liveItem) {
       //dirtyHack = params;
      }
      var videoUuid = params.video.dataValues.uuid;
      var storedSplitData = await getSavedSplit(videoUuid);
      var blocks = []
      //var videoJSON = await peertubeHelpers.videos.loadByIdOrUUID(videoUuid);
      //console.log("⚡️⚡️⚡️⚡️ video helper json",videoJSON)
      if (storedSplitData) {
        for (var split of storedSplitData) {
          let newBlock = {};
          newBlock.name = split.name;
          newBlock.type = "node";
          newBlock.split = split.split;
          if (split.fee) {
            newBlock.fee = split.fee;
          }
          newBlock.address = split.keysend.pubkey;
          if (split.keysend.customData[0] && split.keysend.customData[0].customKey) {
            newBlock.customKey = split.keysend.customData[0].customKey;
            newBlock.customValue = split.keysend.customData[0].customValue;
          }
          blockWrap = {};
          blockWrap.name = "podcast:valueRecipient"
          blockWrap.attributes = newBlock
          blocks.push(blockWrap);
        }
      }
      let customObjects = [];
      let valueBlock;
      if (blocks.length > 0) {
        valueBlock = {
          name: "podcast:value",
          attributes: {
            "type": "lightning",
            "method": "keysend",
            "suggested": "0.00000005000"
          },
          value: blocks,
        }
        customObjects.push(valueBlock);
      }
      //console.log("⚡️⚡️\nCustom Blocks 1",customObjects);
      let captionApi = base + "/api/v1/videos/" + videoUuid + "/captions";
      let captionResult;
      try {
        captionResult = await axios.get(captionApi);
      } catch (err) {
        console.log("⚡️⚡️failed requesting transcript data", err);
      }
      let captionPath, captionLanguage, captionItem;
      //if (captionResult && captionResult.data && captionResult.data.total > 0) {
      //console.log("⚡️⚡️\ncaption result", captionResult.data);
      for (var captionEntry in captionResult.data.data) {
        captionPath = base + captionEntry.captionPath
        if (captionEntry.language) {
          captionLanguage = captionEntry.language.id;
        }
        if (captionPath.indexOf("vtt") > 1) {
          type = "text/vtt"
        } else {
          type = "text/plain"
          //fixed = fixed + "\n" + spacer + `<podcast:transcript url="` + captionPath + `" language="` + captionLanguage + `" type="text/plain" rel="captions"/>`;
        }
        captionItem = {
          name: "podcast:transcript",
          attributes: {
            "url": captionPath,
            "language": captionLanguage,
            "type": type,
            "rel": "captions"
          }
        };
        customObjects.push(captionItem);
      }
      /*let hackItem = {
        name: "enclosure",
        attributes: {
          "url": "https://google.com?",
          "language": "explicit",
          "type": "hornypost",
          "rel": "testes"
        }
      };
      console.log("⚡️⚡️\n\n\n\n\n\nfailed to pull information for provided video id", hackItem);
      customObjects.push(hackItem);
      */
      var apiCall = base + "/api/v1/videos/" + videoUuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️\n\n\n\n\n\nfailed to pull information for provided video id", apiCall);
      }
      if (videoData) {
        let duration = videoData.data.duration;
        let customData = videoData.data.pluginData;
        let videoFiles = videoData.data.streamingPlaylists[0].files;
        let smallest = 999999999
        let filename;
        if (videoFiles) {
          for (var fileOption of videoFiles) {
            //console.log(fileOption);
            if (fileOption.size < smallest) {
              smallest = fileOption.size;
              filename = fileOption.fileUrl
            }
          }
        }
        var enclosure;
        //console.log("\n⚡️⚡️\n\n\nsmallest??",filename,smallest);
        if (filename) {
          enclosure = {
            name: "audioenclosure",
            attributes: {
              "url": filename,
              type: "video/mp4",
              length: duration
            }
          }
        } else {
          enclosure = {
            name: "audioenclosure",
            attributes: {
              "url": filename,
              type: "video/mp4",
              length: duration
            }
          }
        }
        if (enclosure) {
          customObjects.push(enclosure);
        }
        console.log("⚡️⚡️\nplugin data", customData);
        
        if (customData && customData.seasonnode){
          let seasonItem = {
            name: "podcast:season",
            value: await customData.seasonnode.toString()
          };
          if (customData.seasonname){
            seasonItem.attributes={
              "name": customData.seasonname
            }
          }
          customObjects.push(seasonItem);
        }
        
        if (customData && customData.episodenode){
          episodeItem = {
            name: "podcast:episode",
            value: await customData.episodenode.toString()
          };
          if (customData.episodename){
            episodeItem.attributes={
              "display": customData.episodename
            }
          }
          customObjects.push(episodeItem);
        }
        
        if (customData && customData.chapters){
          chaptersItem = {
            name: "podcast:chapters",
            attributes: {
              "url": customData.chapters,
              type: "application/json+chapters"
            }
          };
          customObjects.push(chaptersItem);
        }
       
        if (customData && customData.itemtxt){
         // let txtValue=[].push(customData.itemtxt);
          let txtItem = {
            name: "podcast:txt",
            value: customData.itemtxt
          }
          customObjects.push(txtItem);
        }
        
      }
      console.log("custom objects to add to video",customObjects);
      return result.concat(customObjects);
    }
  })
  const router = getRouter();
  router.use('/walletinfo', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️Request for wallet info\n", req.query)
    }
    if (!enableLnurl && !enableKeysend) {
      return res.status(503).send("No Lightning services enabled for plug-in");
    }
    let foundLightningAddress;
    if (req.query.address) {
      let keysendData;
      let lnurlData;
      let address = req.query.address;
      if (enableKeysend) {
        keysendData = await getKeysendInfo(address);
      }
      if (enableLnurl) {
        lnurlData = await getLnurlInfo(address);
      }
      if (lnurlData || keysendData) {
        let walletData = {};
        walletData.address = address;
        if (keysendData) {
          walletData.keysend = keysendData;
          if (enableDebug) {
            console.log("⚡️⚡️successfully retrieved keysend data for ", address, keysendData);
          }
        }
        if (lnurlData) {
          walletData.lnurl = lnurlData;
          if (enableDebug) {
            console.log("⚡️⚡️successfully retrieved lnurl data for ", address, lnurlData);
          }
        }
        return res.status(200).send(walletData);
      } else {
        console.log("⚡️⚡️lightning address passed in query does not resolve", address);
        return res.status(400).send("Lightning address" + address + "does not resolve");
      }
    }
    /* Videos and channels should have splits, not single wallets.
    if (req.query.video) {
      //var helpervideo = await peertubeHelpers.videos.loadByIdOrUUID(req.query.video);
      apiCall = base + "/api/v1/videos/" + req.query.video;
      console.log("⚡️⚡️ getting video data", apiCall);
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
      }
      if (videoData) {
        let foundLightningAddress = await findLightningAddress(videoData.data.description + " " + videoData.data.support);
        if (foundLightningAddress) {
          console.log("⚡️⚡️lightning address found in video description [" + foundLightningAddress + ']');
          let keysendData = await getKeysendInfo(foundLightningAddress);
          let lnurlData = await getLnurlInfo(foundLightningAddress);
          if (lnurlData || keysendData) {
            let walletData = {};
            walletData.address = foundLightningAddress;
            if (keysendData) {
              walletData.keysend = keysendData;
              console.log("⚡️⚡️successfully retrieved keysend data for wallet in video", videoData.data.channel.name, keysendData);
              //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
            }
            if (lnurlData) {
              walletData.lnurl = lnurlData;
              console.log("⚡️⚡️successfully retrieved lnurl data for wallet in video", videoData.data.channel.name, lnurlData);
              //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

            }
            return res.status(200).send(walletData);
          } else {
            console.log("⚡️⚡️lightning address in video description does not resolve", foundLightningAddress);
          }
        } else {
          console.log("⚡️⚡️no lightning address found in video description");
        }
      }
    }
    if (req.query.channel) {
      apiCall = base + "/api/v1/video-channels/" + req.query.channel;
      console.log("⚡️⚡️ getting channel data", apiCall);
      let channelData;
      try {
        channelData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️failed to pull information for provided channel id", apiCall);
      }
      if (channelData) {
        let foundLightningAddress = await findLightningAddress(channelData.data.description + " " + channelData.data.support);
        if (foundLightningAddress) {
          console.log("⚡️⚡️lightning address found in channel description [" + foundLightningAddress + ']');
          let keysendData = await getKeysendInfo(foundLightningAddress);
          let lnurlData = await getLnurlInfo(foundLightningAddress);
          if (lnurlData || keysendData) {
            let walletData = {};
            walletData.address = foundLightningAddress;
            if (keysendData) {
              walletData.keysend = keysendData;
              console.log("⚡️⚡️successfully retrieved keysend data for wallet in channel", channelData.data.name, keysendData);
            }
            if (lnurlData) {
              walletData.lnurl = lnurlData;
              console.log("⚡️⚡️successfully retrieved lnurl data for wallet in channel", channelData.data.name, lnurlData);
            }
            return res.status(200).send(walletData);
          } else {
            console.log("⚡️⚡️lightning address in channel description does not resolve", foundLightningAddress);
          }
        } else {
          console.log("⚡️⚡️no lightning address found in channel description");
        }
      }
    }
    */
    if (req.query.account) {
      var storedWallet
      try {
        storedWallet = await storageManager.getData("lightning-" + req.query.account.replace(/\./g, "-"));
      } catch (err) {
        console.log("⚡️⚡️failed to get stored lightning address for account", req.query.account, err);
      }
      if (storedWallet) {
        if (enableDebug) {
          console.log("⚡️⚡️ successfully found stored wallet data for account", req.query.account, storedWallet,Date.now()-storedWallet.cache);
          if (storedWallet,Date.now()-storedWallet.cache<(60*60*24)){
            return res.status(200).send(storedWallet);
          } else {
            console.log("⚡️⚡️ saved data expired");
          }
        }
        if (storedWallet.status === 404) {
          console.log("⚡️⚡️404 not found error, cache dates", storedWallet.cache, Date.now() - storedWallet.cache);
        } else {
          //saveWellKnown(req.query.account, storedWallet.keysendData)
          return res.status(200).send(storedWallet);
        }
      } else {
        if (enableDebug) {
          console.log("⚡️⚡️no stored wallet for account", req.query);
        }
      }
      let parts = req.query.account.split("@")
      if (parts.length > 1) {
        apiCall = "https://" + parts[1] + "/api/v1/accounts/" + parts[0];
      } else {
        apiCall = base + "/api/v1/accounts/" + req.query.account;
      }
      let accountData;
      try {
        accountData = await axios.get(apiCall);
      } catch (err) {
        console.log("⚡️⚡️hard failure pulling acount information", apiCall, err);
      }
      if (!accountData) {
        //hack for mastardon's lame api
        apiCall = "https://" + parts[1] + "/api/v1/accounts/lookup?acct=" + parts[0]
        try {
          accountData = await axios.get(apiCall);
        } catch (err) {
          console.log("⚡️⚡️errored trying to pull information from mastodon", apiCall, err);
        }
      }
      if (accountData) {
        let account = accountData.data
        if (enableDebug) {
          console.log("⚡️⚡️account to search for address", account);
        }
        if (account.description) {
          foundLightningAddress = await findLightningAddress(account.description);
        }
        if (!foundLightningAddress && account.fields) {
          for (var field of account.fields) {
            if (field.name.toLowerCase() === "lightning address" || field.name.toLowerCase() === "lud16") {
              foundLightningAddress = field.value;
            }
          }
        }
        if (!foundLightningAddress && account.note) {
          foundLightningAddress = await findLightningAddress(account.note);
        }
        if (foundLightningAddress) {
          let keysendData
          if (enableKeysend) {
            keysendData = await getKeysendInfo(foundLightningAddress);
          }
          let lnurlData;
          if (enableLnurl) {
            lnurlData = await getLnurlInfo(foundLightningAddress);
          }
          if (lnurlData || keysendData) {
            let walletData = {};
            walletData.address = foundLightningAddress;
            if (keysendData) {
              walletData.keysend = keysendData;
              if (req.query.account.indexOf("@") < 0) {
                if (enableDebug) {
                  console.log("attempting to save keysend info", req.query.account)
                }
                saveWellKnown(req.query.account, keysendData);
              }
            }
            if (lnurlData) {
              walletData.lnurl = lnurlData;
            }
            walletData.cache = Date.now();
            if (enableDebug) {
              console.log("⚡️⚡️preparing to save and return found wallet info", req.query.account, walletData.address);
            }
            try {
              storageManager.storeData("lightning-" + req.query.account.replace(/\./g, "-"), walletData);
            } catch {
              console.log("⚡️⚡️failed to store lighting address", req.query.account, walletData);
            }
            return res.status(200).send(walletData);
          } else {
            console.log("⚡️⚡️ no lightning address support enabled", foundLightningAddress, req.query);
          }
        }
        let notFound = { status: 404 };
        notFound.cache = Date.now();
        try {
          storageManager.storeData("lightning-" + req.query.account.replace(/\./g, "-"), notFound);
        } catch {
          console.log("⚡️⚡️hard error storing address not found", req.query.account, notFound);
        }
        return res.status(400).send();
      }
    }
  })
  router.use('/podcast2', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️ podcast2 request ⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️", req.query);
    }
    if (!enableRss) {
      console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️RSS disabled");
      return res.status(403).send();
    }
    if (req.query.channel == undefined) {
      console.log("⚡️⚡️no channel requested", req.query);
      return res.status(404).send();
    }
    let channel = req.query.channel
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
    } catch {
      console.log("⚡️⚡️⚡️⚡️unable to load channel info", apiUrl);
      return res.status(400).send();
    }
    let smallChannelAvatar, largeChannelAvatar, smallPersonAvatar, largePersonAvatar
    if (channelData && channelData.data && channelData.data.avatars && channelData.data.avatars[1]) {
      smallChannelAvatar = channelData.data.avatars[0].path;
      largeChannelAvatar = channelData.data.avatars[1].path;
    }
    if (channelData && channelData.data && channelData.data.ownerAccount && channelData.data.ownerAccount.avatars && channelData.data.ownerAccount.avatars[1]) {
      smallPersonAvatar = channelData.data.ownerAccount.avatars[0].path;
      largePersonAvatar = channelData.data.ownerAccount.avatars[1].path;
    }
    //console.log("⚡️⚡️⚡️⚡️channel info", channelData.data);
    
    let rssUrl = base + "/feeds/podcast/videos.xml?videoChannelId=" + channelData.data.id;
    let rssData;
    try {
      rssData = await axios.get(rssUrl)
    } catch {
      console.log("⚡️⚡️unable to load rss feed for", channel, rssUrl);
      return res.status(400).send();
    }
    //console.log("⚡️⚡️loaded rss feed from", rssUrl);
    let channelGuid;
    apiUrl = base + "/plugins/lightning/router/getchannelguid?channel=" + channel;
    try {
      let guidData = await axios.get(apiUrl);
      if (guidData && guidData.data) {
        //console.log("⚡️⚡️channel guid", guidData.data);
        channelGuid = guidData.data;
      }
    } catch {
      console.log("⚡️⚡️unable to load channel guid", apiUrl);
    }
    //TODO figure out how to get info for livechat plugin as well
    let podData
    try {
      podData = await axios.get(base + "/plugins/lightning/router/getpoddata?channel=" + channel);
    } catch {
      console.log("unable to load PODCAST data");
    }
    if (podData) {
      console.log("⚡️⚡️\n\n\n\n pod dta \n", podData.data);
    }
    let counter = 0;
    let fixed = "";
    let spacer = "";
    let rss = rssData.data;
    let lines = rss.split('\n');
      console.log("⚡️⚡️\n\n\n\n starting linbe loop \n", lines.length,lines[33]);
    //for (const line of lines) {
    let totalSize = lines.length;
    while (counter<totalSize){
      let line = lines[counter];
      console.log(`⚡️line${counter}:`,line)
      counter++;
      spacer = line.split("<")[0];
      if (line.includes("Toraifōsu") && podData && podData.data) {

        if (podData.data.text) {
          line = line + `\n${spacer}<podcast:txt>${podData.data.text[0]}</podcast:txt>`;
        }
        if (podData.data.feedguid) {
          line = line + `\n${spacer}<podcast:guid>${podData.data.feedguid}</podcast:guid>`;
        }
      }
      if (line.includes("<atom:link")) {
        line = `${spacer}<atom:link href="https://${req.get('host')}${req.originalUrl}" rel="self" type="application/rss+xml" />`;
      }
      var customData = {};
      if (line.includes('<guid')) {
        let shortUuid = line.split(">")[1].split("<")[0].split("/")[4]
        try {
          var videoData = await axios.get(base + "/api/v1/videos/" + shortUuid);
          if (videoData && videoData.data) {
            customData = videoData.data.pluginData;
          }
        } catch (err) {
          console.log("⚡️⚡️⚡️⚡️hard error trying to get video data for RSS feed", err);
        }
        if (enableDebug) {
          console.log("⚡️⚡️⚡️⚡️item plugin data", shortUuid, customData);
        }
        /* moved to shared code 
        if (customData.seasonnode) {
          if (customData.seasonname) {
            line = line + `\n${spacer}<podcast:season name ="${customData.seasonname}">${customData.seasonnode}</podcast:season>`;
          } else {
            line = line + `\n${spacer}<podcast:season>${customData.seasonnode}</podcast:season>`;
          }
        }
        if (customData.episodenode) {
          if (customData.episodename) {
            line = line + `\n${spacer}<podcast:episode display ="${customData.episodename}">${customData.episodenode}</podcast:episode>`;
          } else {
            line = line + `\n${spacer}<podcast:episode>${customData.episodenode}</podcast:episode>`;
          }
        }
        if (customData.chapters) {
          line = line + `\n${spacer}<podcast:chapters url="${customData.chapters}" type="application/json+chapters" />`
        }
        if (customData.itemtxt) {
          line = line + `\n${spacer}<podcast:txt>${customData.itemtxt}</podcast:txt>`;
        }
        */
      }
      if (line.includes("<enclosure") > 0) {
        continue;
      }
      if (line.includes("audioenclosure") > 0) {
        line = line.replace("audioenclosure", "enclosure");
      }
      if (line.includes(`title="HLS"`) && !line.includes(`length="`)) {
        console.log("fixing length");
        line = line.replace(`title="HLS"`, `title="HLS" length ="69"`);
      }
      if (line.includes(`title="HLS"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="HLS"`, `title="HLS" type="application/x-mpegURL"`);
      }
      if (line.includes(`title="Audio"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="Audio"`, `title="Audio" type="video/mp4"`);
      }
      if (largeChannelAvatar) {
        line = line.replace(smallChannelAvatar, largeChannelAvatar);
      }
      if (largePersonAvatar) {
        line = line.replace(smallPersonAvatar, largePersonAvatar);
      }
      if (podData && podData.data && podData.data.medium) {
        line = line.replace(`<podcast:medium>video</podcast:medium>`, `<podcast:medium>${podData.data.medium}</podcast:medium>`);
      }
      if (counter > 1) {
        fixed = fixed + '\n' + line;
      } else {
        fixed = line;
      }
    }
    res.setHeader('content-type', 'application/rss+xml');
    console.log("⚡️⚡️\n\n\n\n ending line loop \n",fixed.length);
    return  res.status(200).send(fixed);
    
  })
  router.use('/dirtyhack', async (req, res) => {
    console.log("⚡️⚡️⚡️⚡️ dirty hack",dirtyHack)
    return res.status(200).send(dirtyHack);
  });
  router.use('/setWallet', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️wallet setting request", req.query);
    }
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues && req.query.address) {
      let userName = user.dataValues.username;
      if (enableDebug) {
        console.log("███ got authorized peertube user", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("⚡️⚡️⚡️⚡️ user", userName);
      }
      storageManager.storeData("lightning-" + user.dataValues.username.replace(/\./g, "-"), req.query.address);
      return res.status(200).send(req.query.address);
    }
    return res.status(420).send();
    /* disabling pubkey/custom value for now
    if (!req.query.key) {
      return res.status(400).send("missing key");
    }
    if (req.query.address) {
      let walletInfo = getKeysendInfo(req.query.address);
      if (walletInfo) {
        let lightning = {};
        lightning.address = req.query.address;
        lightning.data = newData
        console.log("⚡️⚡️saving wallet data", req.query.key, lightning);
        //storageManager.storeData("lightning" + "-" + req.query.key, lightning);
        return res.status(200).send(lightning);
      } else {
        console.log("failed to get wallet info for provided address", req.query.address);
        return res.status(400).send();
      }
    }

    if (!req.query.pubkey) {
      return res.status(400).send("missing pubkey");
    }
    if (!req.query.tag) {
      return res.status(400).send("missing tag");
    }
    let newData = {
      status: "OK",
      tag: req.query.tag,
      pubkey: req.query.pubkey,
    }

    if (req.query.customvalue) {
      if (!req.query.customkey) {
        req.query.customkey = "696969";
      }
      let customData = {
        customKey: req.query.customkey,
        customValue: req.query.customvalue,
      }
      let customDataArray = [];
      customDataArray.push(customData);
      newData.customData = customDataArray;
    }
    let lightning = {};
    lightning.data = newData
    console.log("⚡️⚡️saving wallet data", req.query.key, lightning);
    //storageManager.storeData("lightning" + "-" + req.query.key, lightning);
    return res.status(200).send(lightning);
    */
  })
  router.use('/getinvoice', async (req, res) => {
    //  console.log(req);
    if (enableDebug) {
      console.log("⚡️⚡️ getting lnurl invoice", req.query);
    }
    if (!enableLnurl) {
      return res.status(503).send();
    }
    let message = encodeURIComponent(req.query.message);
    let invoiceRequest = req.query.callback + "?amount=" + req.query.amount + "&comment=" + message;
    //console.log("⚡️⚡️invoice request url", invoiceRequest);
    let result;
    try {
      result = await axios.get(invoiceRequest);
    } catch (err) {
      console.log("⚡️⚡️failed to get invoice", err);
      return res.status(400).send(err);
    }
    //console.log("⚡️⚡️ Invoice data",result.data);
    return res.status(200).send(result.data);
  })
  router.use('/getfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting feed id", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      return res.status(420).send("no channel in feed id request");
    }
    let feed;
    let parts = channel.split('@');
    if (parts.length > 1) {
      let feedApi = "https://" + parts[1] + "/plugins/lightning/router/getfeedid?channel=" + parts[0];
      try {
        feed = await axios.get(feedApi);
      } catch {
        console.log("⚡️⚡️hard error getting feed id for ", channel, "from", parts[1], feedApi);
      }
      if (feed && feed.data) {
        //console.log("⚡️⚡️ returning", feed.data, "for", channel,feed.data.toString());
        return res.status(200).send(feed.data.toString());
      }
      return res.status(420).send("remote channel returned no feed id");
    }
    if (channel) {
      try {
        feed = await storageManager.getData("podcast" + "-" + channel)
      } catch (err) {
        console.log("⚡️⚡️error getting feedid", channel);
      }
    }
    //console.log("⚡️⚡️ feed", feed);
    if (feed) {
      return res.status(200).send(feed.toString());
    } else {
      return res.status(400).send("no feed id found for requested channel");
    }
  })
  router.use('/setfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting feed id", req.query);
    }
    let channel = req.query.channel;
    let feedID = req.query.feedid;
    if (channel) {
      try {
        await storageManager.storeData("podcast" + "-" + channel, feedID);
        return res.status(200).send();
      } catch (err) {
        console.log("⚡️⚡️ error storing feedid", channel, feedID);
        return res.status(400).send();
      }
    }
  })
  router.use('/getchatroom', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting chat room", req.query);
    }
    if (!enableChat) {
      return res.status(503).send();
    }
    let channel = req.query.channel;
    let parts = channel.split('@');
    let customChat;
    if (parts.length > 1) {
      let chatApi = "https://" + parts[1] + "/plugins/lightning/router/getchatroom?channel=" + parts[0];
      try {
        customChat = await axios.get(chatApi);
      } catch {
        console.log("⚡️⚡️hard error getting custom chat room for ", channel, "from", parts[1], chatApi);
      }
      if (customChat) {
        //console.log("⚡️⚡️ returning", customChat.toString(), "for", channel);
        return res.status(200).send(customChat.data);
      }
    }
    let chatRoom;
    if (channel) {
      try {
        chatRoom = await storageManager.getData("irc" + "-" + channel)
      } catch (err) {
        console.log("⚡️⚡️error getting chatroom for ", channel);
      }
    }
    //console.log("⚡️⚡️ Irc chat room", chatRoom);
    if (chatRoom) {
      return res.status(200).send(chatRoom);
    } else {
      return res.status(400).send();
    }
  })
  router.use('/setchatroom', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting chatroom", req.query);
    }
    if (!enableChat) {
      return res.status(503).send();
    }
    let channel = req.query.channel;
    let chatroom = req.query.chatroom;
    let parts = channel.split('@');
    if (parts.length > 1) {
      return res.status(503).send();
    }
    if (channel) {
      try {
        await storageManager.storeData("irc" + "-" + channel, chatroom);
        return res.status(200).send(chatroom);
      } catch (err) {
        console.log("⚡️⚡️ error getting chatroom", channel, chatroom);
      }
    }
    return res.status(400).send();
  })
  router.use('/getitemid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting item id", req.query);
    }
    let uuid = req.query.uuid;
    let item;
    if (uuid) {
      try {
        item = await storageManager.getData("podcast" + "-" + uuid);
      } catch (err) {
        console.log("⚡️⚡️ error getting stored itemid", uuid);
      }
    }
    if (item) {
      return res.status(200).send(item.toString());
    } else {
      var apiCall = base + "/api/v1/videos/" + uuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
      }
      if (videoData) {
        let videoHost = videoData.data.channel.host
        if ("https://" + videoHost != base) {
          let hostApi = "https://" + videoHost + "/plugins/lightning/router/getitemid?uuid=" + uuid;
          let hostItemId;
          try {
            hostItemId = await axios.get(hostApi);
          } catch {
            console.log("⚡️⚡️failed to pull item ID from video host", hostApi);
          }
          if (hostItemId) {
            try {
              await storageManager.storeData("podcast" + "-" + uuid, hostItemId);
            } catch {
              console.log("⚡️⚡️failed to store item ID from host", uuid, hostItemId);
            }
            return res.status(200).send(hostItemId.data.toString());
          } else {
            console.log("⚡️⚡️ No id provided by hosting instance");
          }
        }
        let channel = videoData.data.channel.name;
        let feedApi = base + "/plugins/lightning/router/getfeedid?channel=" + channel;
        try {
          feedId = await axios.get(feedApi);
        } catch {
          console.log("⚡️⚡️ error when tring to get feed id ", feedApi);
          return res.status(404).send();
        }

      }
      console.log("⚡️⚡️no videodata available", apiCall);
      return res.status(400).send();
    }
  })
  router.use('/getlnurl', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting lnurl info", req.query);
    }
    if (!enableLnurl) {
      return res.status(503).send();
    }
    let result = getLnurlInfo(req.query.address);
    if (result) {
      return res.status(200).send(result);
    } else {
      return res.status(400).send();
    }
  })
  router.use('/setitemid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting item id", req.query.uuid);
    }
    let uuid = req.query.uuid;
    let itemID = req.query.itemid;
    if (uuid) {
      try {
        await storageManager.storeData("podcast" + "-" + uuid, itemID);
        return res.sendStatus(200);
      } catch (err) {
        console.log("⚡️⚡️error setting item id", uuid, itemID);
        return res.sendStatus(400).send();
      }
    }
  })
  router.use('/getchannelguid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting channel guid", req.query);
    }
    let channel = req.query.channel;
    let channelGuid;
    if (channel) {
      try {
        channelGuid = await storageManager.getData("channelguid" + "-" + channel)
      } catch (err) {
        console.log("⚡️⚡️ error getting channel guid", channel);
        return res.status(400).send();
      }
    }
    if (channelGuid) {
      return res.status(200).send(channelGuid);
    } else {
      //TODO properly create guid
      //let guidResolverUrl = "https://guid.peertube.support/"  
      channelGuid = crypto.randomUUID();
      if (channelGuid) {
        try {
          await storageManager.storeData("channelguid" + "-" + channel, channelGuid);
        } catch {
          console.log("⚡️⚡️failed to get stored guid", channel, channelGuid);
        }
        return res.status(200).send(channelGuid);
      } else {
        console.log("⚡️⚡️ error attempting to generate channel guiid");
        return res.status(400).send();
      }
    }
  })
  router.use('/getsplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️Request for split info\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send();
    }
    var storedSplitData;
    if (req.query.video) {
      storedSplitData = await getSavedSplit(req.query.video);
      if (storedSplitData) {
        return res.status(200).send(storedSplitData);
      }
      let parts;
      if (req.query.channel) {
        parts = req.query.channel.split("@");
        if (parts.length > 1) {
          var apiCall = "https://" + parts[1] + "/plugins/lightning/router/getsplit?video=" + req.query.video;
          let remoteSplit;
          try {
            remoteSplit = await axios.get(apiCall);
          } catch {
            console.log("⚡️⚡️unable to fetch remote split data", apiCall);
          }
          if (remoteSplit) {
            if (enableDebug) {
              console.log("⚡️⚡️returning remote split", apiCall, remoteSplit.data);
            }
            return res.status(200).send(remoteSplit.data);
          }
        }
      }
      //if no channel provided for video, need to look it up channel
      if (!req.query.channel) {
        var apiCall = base + "/api/v1/videos/" + req.query.video;
        let videoData;
        try {
          videoData = await axios.get(apiCall);
        } catch {
          console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
        }
        if (videoData) {
          let videoChannel = videoData.data.channel.name;
          let videoHost = "https://" + videoData.data.channel.host;
          storedSplitData = await getSavedSplit(videoChannel);
          console.log("⚡️⚡️retrieved chaNNEL split info for video", videoChannel, storedSplitData);
          if (storedSplitData) {

            return res.status(200).send(storedSplitData);
          }
          if (videoHost != base) {
            remoteWalletApi = videoHost + "/plugins/lightning/router/getsplit?channel=" + channel.name;
            let remoteSplitData;
            try {
              remoteSplitData = await axios.get(remoteWalletApi);
            } catch {
              console.log("failed to pull remote split info", apiCall);
            }
            if (remoteSplitData) {
              return res.status(200).send(remoteSplitData);
            }
          }
          //let split
          console.log("⚡️⚡️channels", videoData.data.channel);
          let foundLightningAddress = await findLightningAddress(videoData.data.description + " " + videoData.data.support + " " + videoData.data.channel.description + " " + videoData.data.channel.support + " " + videoData.data.account.description);
          if (foundLightningAddress) {
            console.log("⚡️⚡️lightning address found in video description [" + foundLightningAddress + ']');
            let keysendData = await getKeysendInfo(foundLightningAddress);
            let lnurlData = await getLnurlInfo(foundLightningAddress);
            if (lnurlData || keysendData) {
              let walletData = {};
              walletData.address = foundLightningAddress;
              if (keysendData) {
                walletData.keysend = keysendData;
                console.log("⚡️⚡️successfully retrieved keysend data for wallet in video", videoData.data.channel.name, keysendData);
                //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
              }
              if (lnurlData) {
                walletData.lnurl = lnurlData;
                console.log("⚡️⚡️successfully retrieved lnurl data for wallet in video", videoData.data.channel.name, lnurlData);
                //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

              }
              if (walletData.keysend) {
                if (walletData.address.indexOf("fountain.fm") > 0) {
                  walletData.keysend = null;
                }
              }
              var splitData = new Array();
              walletData.split = 100;
              splitData.push(walletData);
              if (hostWalletData && (videoHost == base)) {
                splitData[0].split = 100 - hostWalletData.split;
                splitData.push(hostWalletData);
              }
              try {
                await storageManager.storeData("lightningsplit" + "-" + req.query.video, splitData);
              } catch {
                console.log("⚡️⚡️failed to store lightning split", req.query.video, splitData);
              }
              return res.status(200).send(splitData);
            } else {
              console.log("⚡️⚡️lightning address in video description does not resolve", foundLightningAddress);
            }
          } else {
            console.log("⚡️⚡️no lightning address found in video description");
          }
        }
      }
      //console.log("unable to find any split info in video data");
      //return res.status(400).send();
    }
    if (req.query.channel) {
      var storedSplitData;
      try {
        storedSplitData = await storageManager.getData("lightningsplit" + "-" + req.query.channel);
      } catch {
        console.log("⚡️⚡️failed to get lightning split", req.query.channel);
      }
      if (storedSplitData) {
        for (var splitSlot in storedSplitData) {
          if (storedSplitData[splitSlot].fee) {
            console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️", storedSplitData[splitSlot].address, storedSplitData[splitSlot].split);
            storedSplitData[splitSlot] = hostWalletData;
            console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️", storedSplitData[splitSlot].address, storedSplitData[splitSlot].split);
          }
        }
        return res.status(200).send(storedSplitData);
      }
      let remoteHost, remoteChannel;
      if (req.query.channel.indexOf("@") > 1) {
        let channelParts = req.query.channel.split("@");
        remoteHost = channelParts[1];
        remoteChannel = channelParts[0];
      }
      var apiCall;
      if (remoteHost) {
        console.log("⚡️⚡️getting remote data");
        apiCall = "https://" + remoteHost + "/plugins/lightning/router/getsplit?channel=" + remoteChannel;
        let remoteSplit;
        try {
          remoteSplit = await axios.get(apiCall);
        } catch {
          console.log("⚡️⚡️unable to fetch remote split data", apiCall);
        }
        if (remoteSplit) {
          if (enableDebug) {
            console.log("⚡️⚡️returning remote split", apiCall, remoteSplit.data);
          }
          return res.status(200).send(remoteSplit.data);
        }
      }
      apiCall = base + "/api/v1/video-channels/" + req.query.channel;
      let channelData;
      try {
        channelData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️failed to pull information for provided channel id", apiCall);
      }
      if (channelData) {
        //console.log("channeldata",channelData);
        let foundLightningAddress = await findLightningAddress(channelData.data.description + " " + channelData.data.support);
        if (foundLightningAddress) {
          let keysendData, lnurlData;
          if (enableKeysend) {
            keysendData = await getKeysendInfo(foundLightningAddress);
          }
          if (enableLnurl) {
            lnurlData = await getLnurlInfo(foundLightningAddress);
          }
          if (lnurlData || keysendData) {
            let walletData = {};
            walletData.address = foundLightningAddress;
            if (keysendData) {
              walletData.keysend = keysendData;
            }
            if (lnurlData) {
              walletData.lnurl = lnurlData;
            }
            var splitData = new Array;

            walletData.split = 100;
            splitData.push(walletData);
            if (hostWalletData) {
              splitData[0].split = 100 - hostWalletData.split;
            }
            splitData.push(hostWalletData);
            try {
              await storageManager.storeData("lightningsplit" + "-" + req.query.channel, splitData);
              saveWellKnownSplit(req.query.channel, splitData);
            } catch {
              console.log("⚡️⚡️failed to store lightning split", req.query.channel, splitData);
            }
            return res.status(200).send(splitData);
          } else {
            console.log("⚡️⚡️lightning address in channel description does not resolve", foundLightningAddress);
          }
        } else {
          console.log("⚡️⚡️no lightning address found in channel description");
        }
        return res.status(400).send();
      }
    }
    console.log("⚡️⚡️unable to lookup split info for", req.query);
    return res.status(400).send();
  })
  router.use('/addsplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️add split called\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send();
    }
    var storedSplitData;
    var split = new Array();
    var newAddress = req.query.splitaddress;
    var newSplit = req.query.split;
    var channel = req.query.channel
    var name = req.query.name;
    var customKey = req.query.customkey;
    var customValue = req.query.customvalue;
    var node = req.query.node;
    var customKeysend = req.query.customkeysend;
    var video = req.query.video;
    if (video) {
      try {
        storedSplitData = await storageManager.getData("lightningsplit" + "-" + video);
      } catch {
        console.log("⚡️⚡️failed to get lightning split for video", video);
      }
      console.log("⚡️⚡️retrieved split info for video ", video, "\n", storedSplitData);
      if (!storedSplitData) {
        console.log("⚡️⚡️stored split data not found");
        if (video) {
          console.log("⚡️⚡️base", base);
          var apiCall = base + "/api/v1/videos/" + video;
          console.log("⚡️⚡️ getting video data", apiCall);
          let videoData;
          try {
            videoData = await axios.get(apiCall);
          } catch {
            console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
          }
          if (videoData) {
            console.log("⚡️⚡️channel data", videoData.data.channel);
            if (!channel) {
              channel = videoData.data.channel.name;
            }
            storedSplitData = await storageManager.getData("lightningsplit" + "-" + channel);
            //let foundLightningAddress = await findLightningAddress(videoData.data.description + " " + videoData.data.support + " " + videoData.data.channel.description + " " + videoData.data.channel.support + " " + videoData.data.account.description);
            if (storedSplitData) {
              split = storedSplitData;
              /*
              console.log("⚡️⚡️split data found");
              let keysendData = await getKeysendInfo();
              let lnurlData = await getLnurlInfo();
              if (lnurlData || keysendData) {
                let walletData = {};
                walletData.address = foundLightningAddress;
                if (keysendData) {
                  walletData.keysend = keysendData;
                  console.log("⚡️⚡️successfully retrieved keysend data for wallet in video", videoData.data.channel.name, keysendData);
                  //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
                }
                if (lnurlData) {
                  walletData.lnurl = lnurlData;
                  console.log("⚡️⚡️successfully retrieved lnurl data for wallet in video", videoData.data.channel.name, lnurlData);
                  //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

                }
                if (walletData.keysend) {
                  if (walletData.address.indexOf("fountain.fm") > 0) {
                    walletData.keysend = null;
                  }
                }
                var splitData = new Array();
                walletData.split = 100;
                splitData.push(walletData);
                if (hostWalletData && (hostWalletData.split > 1)) {
                  splitData[0].split = 100 - hostWalletData.split;
                }
                splitData.push(hostWalletData);
                //await storageManager.storeData("lightningsplit" + "-" + req.query.video, splitData);
                return res.status(200).send(splitData);
              } else {
                console.log("⚡️⚡️lightning address in video description does not resolve", foundLightningAddress);
              }
              */
            } else {
              console.log("⚡️⚡️no lightning address found in video description");
            }
          }
        }

      } else {
        split = storedSplitData;
      }
    } else if (req.query.channel) {
      try {
        storedSplitData = await storageManager.getData("lightningsplit" + "-" + req.query.channel);
      } catch {
        console.log("⚡️⚡️failed to get lightning split", req.query.channel);
      }
      if (storedSplitData) {
        console.log("⚡️⚡️add split retrieved chaNNEL split info", req.query.channel, "\n", storedSplitData.length);
        split = storedSplitData;

      } else {
        console.log("⚡️⚡️no stored split, unable to add", req.query);
        return res.status(400).send();
      }
    }
    console.log("⚡️⚡️⚡️⚡️ got split", channel, video, split);
    if (!split) {
      console.log("⚡️⚡️Unable to add split", req.query);
      return res.status(400).send();
    }
    console.log("⚡️⚡️split", split);
    console.log("⚡️⚡️Attempt to add new address [" + newAddress + ']', customKeysend);
    let walletData = { "keysend": { "tag": "keysend", "customData": [{}] } };
    if (newAddress) {
      walletData.address = newAddress;
    } else {
      walletData.address = "custom"
    }
    if (name) {
      walletData.name = name;
    } else {
      walletData.name = "anon";
    }
    if (newSplit) {
      walletData.split = parseInt(newSplit);
      if (!walletData.split) {
        walletData.split = 0;
      }
    }
    if (customKeysend) {
      walletData.customKeysend = true;
      if (node) {
        walletData.keysend.pubkey = node;
      }

      if (customKey) {
        walletData.keysend.customData[0].customKey = customKey;
        //  split[slot].customKeysend = true;
      }
      if (customValue) {
        walletData.keysend.customData[0].customValue = customValue;
        //   split[slot].customKeysend = true;
      }
      console.log("⚡️⚡️ setup custom wallet", walletData);
    } else {
      let keysendData = await getKeysendInfo(newAddress);
      let lnurlData = await getLnurlInfo(newAddress);
      if (lnurlData || keysendData) {
        if (keysendData) {
          walletData.keysend = keysendData;
          console.log("⚡️⚡️no walletsuccessfully retrieved keysend data for wallet in channel", channel, keysendData);
          //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
        } else {
          console.log("⚡️⚡️no keysend info")
        }
        if (lnurlData) {
          walletData.lnurl = lnurlData;
          console.log("⚡️⚡️successfully retrieved lnurl data for wallet in channel", channel, lnurlData);
          //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
        } else {
          console.log("⚡️⚡️no keysend info")
        }
      } else {
        console.log("⚡️⚡️no wallet data retured for address", newAddress);
        return res.status(404).send();
      }
      console.log("⚡️⚡️ wallet", walletData);
    }
    //var splitData = new Array;
    split.push(walletData);
    let otherSplit = 0
    for (i = 1; i < split.length; i++) {
      console.log("⚡️⚡️split", i, split[i]);
      if (parseInt(split[i].split) < 1) {
        split[i] = 1;
      }
      otherSplit = otherSplit + split[i].split;
    }
    console.log("⚡️⚡️othersplit", otherSplit);

    let creatorSplit = split[0].split - newSplit
    split[0].split = parseInt(creatorSplit);
    console.log("⚡️⚡️split about to be written to storage manager", split);
    try {
      if (!req.query.channel && req.query.video) {
        storageManager.storeData("lightningsplit" + "-" + req.query.video, split);
      } else {
        storageManager.storeData("lightningsplit" + "-" + channel, split);
        saveWellKnownSplit(channel, split);

      }
    } catch {
      console.log("⚡️⚡️failed to store lightning split", channel, split);
    }
    await pingPI(channel);
    return res.status(200).send(split);
  })
  router.use('/updatesplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️updating split info\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send();
    }
    var storedSplitData;
    var split;
    var newAddress = req.query.splitaddress
    var video = req.query.video;
    var newSplit = req.query.split;
    var channel = req.query.channel;
    var slot = req.query.slot;
    var name = req.query.name;
    var customKey = req.query.customkey;
    var customValue = req.query.customvalue;
    var node = req.query.node;
    var customKeysend = req.query.customkeysend;
    if (!slot) {
      return res.status(400).send("no split specified to update");
    }
    if (video && !channel) {
      storedSplitData = await getSavedSplit(video);
      if (enableDebug) {
        console.log("⚡️⚡️retrieved split info for video ", video, "\n", storedSplitData);
      }
      if (!storedSplitData) {
        console.log("⚡️⚡️stored split data for video not found");
        console.log("⚡️⚡️base", base);
        var apiCall = base + "/api/v1/videos/" + video;
        console.log("⚡️⚡️ getting video data", apiCall);
        let videoData;
        try {
          videoData = await axios.get(apiCall);
        } catch {
          console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
          return res.status(400).send();
        }
        if (videoData && !channel) {
          console.log("⚡️⚡️getting channel split instead", videoData.data.channel.name);
          channel = videoData.data.channel.name;

        } else {
          console.log("⚡️⚡️failed to find video data", apiCall);
          return res.status(400).send();
        }
      } else {
        split = storedSplitData;
      }
    }
    if (channel && !split) {
      split = await getSavedSplit(channel);
      console.log("⚡️⚡️retrieved chaNNEL split info", channel, "\n", split);
    }
    console.log("⚡️⚡️retrieved split info", split);
    if (split) {
      //TODO may need to relook at this
      if (!customKeysend) {
        keysendData = await getKeysendInfo(newAddress);
      }
      //let lnurlData = await getLnurlInfo(newAddress);
      if (enableDebug) {
        console.log(`⚡️⚡️updating from`, split[slot]);
      } if (newAddress) {
        split[slot].address = newAddress;
      }
      if (newSplit) {
        split[slot].split = parseInt(newSplit);
        if (!split[slot].split) {
          split[slot].split = 0;
        }
      }
      if (customKeysend) {
        console.log("⚡️⚡️custom keysend enabled")
        split[slot].customKeysend = true;
        if (node) {
          split[slot].keysend.pubkey = node;
          //split[slot].customKeysend = true;
        }
        if (!split[slot].keysend.customData) {
          split[slot].keysend.customData = [{}];
        }
        if (customKey != split[slot].keysend.customData[0].customKey) {
          split[slot].keysend.customData[0].customKey = customKey;
          //  split[slot].customKeysend = true;
        }
        if (customValue != split[slot].keysend.customData[0].customValue) {
          split[slot].keysend.customData[0].customValue = customValue;
          //   split[slot].customKeysend = true;
        }
      } else {
        console.log("⚡️⚡️regular lightning address keysend");
        split[slot].keysend = keysendData;
        split[slot].customKeysend = false;
      }
      //console.log("⚡️⚡️customs ",split[slot].keysend,split[slot].keysend.customData);
      if (name) {
        split[slot].name = name;
      }

      //split[slot].keysend = keysendData;
      //split[slot].lnurl = lnurlData;
      let otherSplit = 0;
      for (i = 1; i < split.length; i++) {
        console.log("⚡️⚡️split", i, split[i].split, split[i].address);
        if (parseInt(split[i].split) < 1) {
          split[i].split = 1
        }
        otherSplit = otherSplit + parseInt(split[i].split);
      }
      console.log("⚡️⚡️othersplit", otherSplit);
      let creatorSplit = 100 - otherSplit
      split[0].split = parseInt(creatorSplit);
      console.log("⚡️⚡️ split", split);
      try {
        if (req.query.channel) {
          await saveSplit(channel, split);
          saveWellKnownSplit(channel, split);
        }
        if (req.query.video) {
          await saveSplit(video);
        }
      } catch {
        console.log("⚡️⚡️failed to store lightning split", req.query.video, channel, split);
      }
      console.log("⚡️⚡️updated slot", slot, "with", split[slot]);
      //saveWellKnownSplit(channel,split); 
      if (channel) {
        await pingPI(channel);
      }
      return res.status(200).send(split)
    }
    return res.status(400).send();
  })
  router.use('/removesplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️removing split info\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send();
    }
    var storedSplitData;
    var split;
    var slot = req.query.slot;
    var channel = req.query.channel;
    var video = req.query.video;
    if (!slot) {
      return res.status(400).send("no slot to remove specified");
    }
    if (req.query.video) {
      storedSplitData = await getSavedSplit(video);
      var apiCall;
      console.log("⚡️⚡️retrieved split info", req.query.key, "\n", storedSplitData);
      if (!storedSplitData) {
        console.log("⚡️⚡️stored split data for video not found");
        if (req.query.video) {
          console.log("⚡️⚡️base", base);
          apiCall = base + "/api/v1/videos/" + req.query.video;
          console.log("⚡️⚡️ getting video data", apiCall);
          let videoData;
          try {
            videoData = await axios.get(apiCall);
          } catch {
            console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
          }
          if (videoData) {
            console.log("⚡️⚡️video channel data", videoData.data.channel);
            channel = videoData.data.channel
          }
        }

      } else {
        split = storedSplitData;
      }
    }
    if (channel) {
      try {
        split = await getSavedSplit(channel);
      } catch {
        console.log("⚡️⚡️failed to get lightning split for channel", channel);
      }
      console.log("⚡️⚡️retrieved chaNNEL split info", channel, "\n", split);
    }
    if (split) {
      console.log(`⚡️⚡️removing`, split[slot].address, " of ", split.length, " from ", channel);
      let otherSplit = 0
      let newSplit = new Array();
      for (i = 0; i < split.length; i++) {
        console.log("⚡️⚡️split", i, "of ", split.length, split[i].address);
        if (i == slot) {
          console.log("⚡️⚡️skipping", i)
        } else {
          newSplit.push(split[i]);
          if (i > 0) {
            otherSplit = otherSplit + split[i].split;
          }
        }
      }
      console.log("⚡️⚡️othersplit", otherSplit);
      let creatorSplit = 100 - otherSplit
      newSplit[0].split = parseInt(creatorSplit);
      console.log("⚡️⚡️split about to be writ", video, newSplit.length);
      try {
        if (req.query.channel) {
          await saveSplit(channel, newSplit);
          saveWellKnownSplit(channel, split);
        }
        if (req.query.video) {
          await saveSplit(video, newSplit);
        }
      } catch (err) {
        console.log("⚡️⚡️failed to store lightning split", channel, newSplit, err);
      }
      console.log("⚡️⚡️⚡️⚡️ slot removed", slot, ".", newSplit.length, "splits remaining");
      await pingPI(channel);
      return res.status(200).send(newSplit);
    } else {
      console.log("⚡️⚡️stored split data not found");
      //TODO check channel owner account for wallet info
      return res.status(400).send();
    }
  })
  router.use('/getversion', async (req, res) => {
    return res.status(200).send(version);
  })
  router.use('/createsplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️creating split info\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send("Lightning not enabled by sysop");
    }
    var storedSplitData;
    var split = new Array();
    var newAddress = req.query.splitaddress;
    var newSplit = req.query.split;
    var channel = req.query.channel
    var name = req.query.name;
    if (req.query.video) {
      storedSplitData = await getSavedSplit(video)
      if (enableDebug) {
        console.log("⚡️⚡️retrieved video split info", video, "\n", storedSplitData);
      }
      if (!storedSplitData) {
        console.log("⚡️⚡️stored video split data not found");
        if (req.query.video) {
          console.log("⚡️⚡️base", base);
          var apiCall = base + "/api/v1/videos/" + req.query.video;
          console.log("⚡️⚡️ getting video data", apiCall);
          let videoData;
          try {
            videoData = await axios.get(apiCall);
          } catch {
            console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
          }
          if (videoData) {
            console.log("⚡️⚡️video channel data", videoData.data.channel);
            let foundLightningAddress = await findLightningAddress(videoData.data.description + " " + videoData.data.support + " " + videoData.data.channel.description + " " + videoData.data.channel.support + " " + videoData.data.account.description);
            if (foundLightningAddress) {
              console.log("⚡️⚡️lightning address found in video description [" + foundLightningAddress + ']');
              let keysendData = await getKeysendInfo(foundLightningAddress);
              let lnurlData = await getLnurlInfo(foundLightningAddress);
              if (lnurlData || keysendData) {
                let walletData = {};
                walletData.address = foundLightningAddress;
                if (keysendData) {
                  walletData.keysend = keysendData;
                  console.log("⚡️⚡️successfully retrieved keysend data for wallet in video", videoData.data.channel.name, keysendData);
                  //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
                }
                if (lnurlData) {
                  walletData.lnurl = lnurlData;
                  console.log("⚡️⚡️successfully retrieved lnurl data for wallet in video", videoData.data.channel.name, lnurlData);
                  //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

                }
                var splitData = new Array();
                walletData.split = 100;
                if (name) {
                  walletData.name = name;
                } else {
                  walletData.name = "anon";
                }
                splitData.push(walletData);
                if (hostWalletData && parseInt(hostwalletData.split) > 0) {
                  splitData[0].split = 100 - hostWalletData.split;
                }
                splitData.push(hostWalletData);
                //await storageManager.storeData("lightningsplit" + "-" + req.query.video, splitData);
                return res.status(200).send(splitData);
              } else {
                console.log("⚡️⚡️lightning address in video description does not resolve", foundLightningAddress);
              }
            } else {
              console.log("⚡️⚡️no lightning address found in video description");
            }
          }
        }
        console.log("⚡️⚡️Unable to add split", req.query);
        return res.status(400).send();

      } else {
        split = storedSplitData;
      }
    } else if (channel) {
      if (newAddress.length === 66) {
      }
      storedSplitData = await getSavedSplit(channel);
      if (storedSplitData) {
        console.log("⚡️⚡️add split retrieved chaNNEL split info", req.query.channel, "\n", storedSplitData.length);
        console.log('⚡️⚡️already existing splitData for', req.query.channel, storedSplitData);
        return res.status(400).send();
      } else {
        console.log("⚡️⚡️stored split data not found, generating channel split data", req.query.channel);
        //return res.status(400).send();
      }
    }
    console.log("⚡️⚡️split", split);
    console.log("⚡️⚡️Create split attempting to add new address [" + newAddress.length + ']', req.query);
    let keysendData, lnurlData;

    if (newAddress.length === 66) {
      keysendData = { pubkey: newAddress };
      keysendData.customData = [];
      newAddress = "custom";
    } else {
      if (newAddress.indexOf("@") < 0) {
        console.log("⚡️⚡️malformed address without @");
        return res.status(400).send();
      }
      keysendData = await getKeysendInfo(newAddress);
      lnurlData = await getLnurlInfo(newAddress);
    }
    let walletData = {};
    if (lnurlData || keysendData) {
      walletData.address = newAddress;
      walletData.split = 100;
      if (keysendData) {
        walletData.keysend = keysendData;
        console.log("⚡️⚡️successfully retrieved keysend data for wallet in channel", channel, keysendData);
        //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
      }
      if (lnurlData) {
        walletData.lnurl = lnurlData;
        console.log("⚡️⚡️successfully retrieved lnurl data for wallet in channel", channel, lnurlData);
        //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

      }
      //var splitData = new Array;
      if (name) {
        walletData.name = name;
      } else {
        walletData.name = newAddress;
      }
      split.push(walletData);
      if (hostWalletData && hostWalletData.split > 0) {

        split[0].split = 100 - hostWalletData.split;
        split.push(hostWalletData);
      } else {
        split[0].split = 100;
      }
      if (enableDebug) {
        console.log("⚡️⚡️saving created channel split\n", channel, split)
      }
      await saveSplit(channel, split);
      await pingPI(channel);
      return res.status(200).send(split);
    } else {
      console.log("⚡️⚡️lightning address in channel description does not resolve", newAddress);
      return res.status(400).send("Lightning address failed to resolve");
    }
    return res.status(400).send("failed to update");
  })
  router.use('/callback', async (req, res) => {
    console.log("\n⚡️⚡️\n callback", req.query, req.body);
    var state;
    if (req.query.state && req.query.state != 'peertube') {
      state = await storageManager.getData("alby-" + req.query.state.replace(/\./g, "-"));
      console.log("\n⚡️⚡️\ncurrent wallet value", state, req.query.state);
    } 
    if (state == 'pending'  || req.query.state == 'peertube') {
      let callbackUrl = base + "/plugins/lightning/router/callback";
      var formFull = new URLSearchParams();
      //formFull = new FormData();
      formFull.append('code', req.query.code);
      formFull.append('grant_type', 'authorization_code');
      formFull.append('redirect_uri', callbackUrl);
      formFull.append('client_id', client_id);
      formFull.append('client_secret', client_secret);

      let url = "https://api.getalby.com/oauth/token";
      let response;
      let albyWalletData;
      try {
        response = await axios.post(url, formFull, { auth: { username: client_id, password: client_secret } });
      } catch (err) {
        console.log("\n⚡️⚡️⚡️⚡️axios failed to post to alby", err, url, formFull)
      }
      if (response && response.data) {
        console.log("\n⚡️⚡️⚡️⚡️response to token request axios", response.data);
        //storageManager.storeData("alby-" + req.query.state.replace(/\./g, "-"), response.data);
        let albyToken = response.data.access_token
        
        let headers = { headers: { "Authorization": `Bearer ` + albyToken } }
        let walletApiUrl = "https://api.getalby.com/user/me"
        try {

          albyWalletData = await axios.get(walletApiUrl, headers);
        } catch (err) {
          console.log("\n⚡️⚡️⚡️⚡️error attempting to get wallet data\n", walletApiUrl, headers, err);
        }
        console.log("\n⚡️⚡️⚡️⚡️wallet data:\n", albyWalletData.data);
      }
      if (req.query.state == 'peertube' && enableAlbyAuth){
        let userName = albyWalletData.data.email.split("@")[0];
        let userEmail = albyWalletData.data.email;
        let displayName = albyWalletData.data.name;
        let lightning = albyWalletData.data.lightning_address;
        if (!displayName) {
          displayName=userName;
        }
        if (!userName || !userEmail){return}
        storageManager.storeData("alby-" + userName.replace(/\./g, "-"), response.data);
        storageManager.storeData("lightning-" + userName.replace(/\./g, "-"), lightning);
        console.log("returned user data",userName,userEmail,displayName);
        return result.userAuthenticated({
          req,
          res,
          username: userName,
          email: userEmail,
          role: 2,
          displayName: displayName,
        });
      }
      storageManager.storeData("alby-" + req.query.state.replace(/\./g, "-"), response.data);
      storageManager.storeData("lightning-" + req.query.state.replace(/\./g, "-"), albyWalletData.data.lightning_address);
      return res.status(200).send(`<h1>User authorized to boost</h1>hr<div class="callout" data-closable>
        <img src="https://media.tenor.com/bwNyT4OBWz4AAAAC/yay-surprise.gif">
        </div>`);
    }
    //TODO fix this
    //return res.redirect(base);
   
  })
  router.use('/setauthorizedwallet', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting authorized wallet", req.query);
    }
    let userName;
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues) {
      if (enableDebug) {
        console.log("⚡️⚡️ got authorized peertube user", user.dataValues.username);
      }
      userName = user.dataValues.username;
    } else {
      console.log("⚡️⚡️ not a valid user");
      return res.status(200).send("not a logged in PeerTube user (" + req.query + ") [" + user + ")");
    }
    if (req.query.clear) {
      storageManager.storeData("alby-" + userName.replace(/\./g, "-"), "cleared");
      console.log("⚡️⚡️cleared", userName);
    } else {
      storageManager.storeData("alby-" + userName.replace(/\./g, "-"), "pending");
      console.log("⚡️⚡️set", userName, "to pending");
    }
    return res.status(200).send(true);
  })
  router.use('/checkauthorizedwallet', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️checking authorized wallet", req.query);
    }
    let userName;
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues) {
      userName = user.dataValues.username;
    } else {
      console.log("⚡️⚡️no user found in header");
      return res.status(420).send(` user ${req}`);
    }
    let albyData = await storageManager.getData("alby-" + userName.replace(/\./g, "-"));
    console.log("⚡️⚡️stored data", albyData);
    if (albyData && albyData.access_token) {
      return res.status(200).send(true);
    } else {
      console.log("failed to get alby data", albyData);
      return res.status(420).send(`no stored alby access token for ${userName}`);
    }
  })
  router.use('/sendalbypayment', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️sending payment", req.query, req.body);
    }
    let userName;
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues) {
      userName = user.dataValues.username;
    } else {
      console.log("⚡️⚡️no user found");
      return res.status(420).send();
    }
    let albyData = await storageManager.getData("alby-" + userName.replace(/\./g, "-"));
    console.log("⚡️⚡️stored data", albyData);
    if (albyData && albyData.access_token) {
      let albyToken = albyData.access_token
      let albyWalletData
      let headers = { headers: { "Authorization": `Bearer ` + albyToken } }
      let walletApiUrl = "https://api.getalby.com/payments/keysend"
      let data = req.body;
      console.log("-=--=-=-=-=-", data, headers, walletApiUrl)
      dirtyHack=data;
      try {
        albyWalletData = await axios.post(walletApiUrl, data, headers)
      } catch (err) {
        console.log("\n⚡️⚡️⚡️⚡️error attempting to send boost\n", err.response.status);
        albyWalletData = err.response.status;
      }
      if (albyWalletData == 401) {
        console.log("need to refresh token!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        let albyUrl = 'https://api.getalby.com/oauth/token'
        var form = new URLSearchParams();
        form.append('refresh_token', albyData.refresh_token);
        form.append('grant_type', "refresh_token");
        let headers = { auth: { username: client_id, password: client_secret } };
        let response;
        try {
          response = await axios.post(albyUrl, form, headers);
        } catch (err) {
          console.log("\n⚡️⚡️⚡️⚡️axios failed to refresh alby token", err, albyUrl, form);
        }
        if (response && response.data) {
          console.log("\n⚡️⚡️⚡️⚡️response to token refreshrequest axios", response.data);
          storageManager.storeData("alby-" + userName.replace(/\./g, "-"), response.data);
          albyToken = response.data.access_token;
        }
      }
      headers = { headers: { "Authorization": `Bearer ` + albyToken } }
      try {
        albyWalletData = await axios.post(walletApiUrl, data, headers)
      } catch (err) {
        console.log("\n⚡️⚡️⚡️⚡️error attempting to send boost\n", err.response.status);
        return res.status(420);
      }
      return res.status(200).send(true);
    } else {
      return res.status(420).send(false);
    }
  })
  router.use('/enablewebhook', async (req, res) => {
    let albyHook = "https://api.getalby.com/webhook_endpoints"
    let body = {};
    body.description = "super chat invoices";
    body.url = base + "/plugins/lightning/router/clearedinvoice";
    body.filter_types = ["invoice.incoming.settled"]
    let albyData = await storageManager.getData("alby-" + botAccount);
    let response;
    console.log("⚡️⚡️stored data", albyData);
    if (albyData && albyData.access_token) {
      let albyToken = albyData.access_token
      let albyWalletData
      let headers = { headers: { "Authorization": `Bearer ` + albyToken } }
      console.log("⚡️⚡️⚡️⚡️", body, headers, albyHook)
      try {
        response = await axios.post(albyHook, body, headers)
        console.log("\n⚡️⚡️⚡️⚡️ created web hook", response)
        return res.status(200).send(response.data);
      } catch (err) {
        console.log("\n⚡️⚡️⚡️⚡️error attempting to set webhook\n", err);
        albyWalletData = err.response.status;
      }
      console.log('⚡️⚡️⚡️⚡️ response', response, albyWalletData);
      if (albyWalletData == 401) {
        console.log('⚡️⚡️⚡️⚡️ attempting to refresh token');
        let newToken = await refreshAlbyToken(albyData.refresh_token);
        if (newToken && newToken.data) {

          console.log("\n⚡️⚡️⚡️⚡️response to token refreshrequest axios", newToken.data);
          storageManager.storeData("alby-" + botAccount.replace(/\./g, "-"), newToken.data);
          try {
            response = await axios.post(albyHook, body, headers)
            return res.status(200).send(response.data);
          } catch (err) {
            console.log("\n⚡️⚡️⚡️⚡️error attempting to set webhook\n", err);
            albyWalletData = err.response.status;
            return res.status(420).send(err);
          }
        } else {

        }

      }
    } else {
      console.log('⚡️⚡️⚡️⚡️ no stored wallet data for bot', botAccount);
    }

  })
  router.use('/clearedinvoice', async (req, res) => {
    let suid = req.body.payer_name + (Math.round(parseInt(req.body.creation_date) / 10));
    if (invoices.includes(suid)) {
      console.log("⚡️⚡️\n\n\n\n\n⚡️⚡️duplicate payment ", suid);
      return res.status(200).send();
    }
    invoices.push(suid);
    if (enableDebug) {
      console.log("⚡️⚡️\n\n\n\n\n⚡️⚡️cleared payment", suid, req.query, req.body, req.headers);
    }
    let tip = req.body.fiat_in_cents.toString();
    if (simpletipToken && tip > 1000) {


      let simpleTip = {
        "Source": simpletipToken,
        "SourceID": req.body.identifier,
        "UserName": req.body.payer_name,
        "TextContent": req.body.boostagram.message,
        "PaymentAmount": tip
      }
      console.log("simple tip ", simpleTip)
      let tipApi;
      if (simpletipToken) {
        tipApi = "https://simpletipapi.azurewebsites.net/Nugget/ExternalNugget"
      } else {
        tipApi = base + "/plugins/lightning/router/dirtyhack"
      } let simpleTipResult
      try {
        simpleTipResult = await axios.post(tipApi, simpleTip);
      } catch (err) {
        console.log("⚡️⚡️\n\n\n\n\n⚡️⚡️ simple tip failed", tipApi, err.response.data);
      }
      console.log("⚡️⚡️\n\n\n\n\n⚡️⚡️ simple tip", simpleTipResult);
    }
    if (botToken && req.body.boostagram && req.body.boostagram.message) {
      let source = "";
      if (req.body.boostagram.app_name != "PeerTube") {
        source = "using " + req.body.boostagram.app_name;
      }
      let postBody = `${req.body.boostagram.value_msat_total / 1000} Sat ${tipVerb} from ${req.body.payer_name} ${source} \n${req.body.boostagram.message}`;
      if (req.body.boostagram.episode_guid) {
        let parts = req.body.boostagram.episode_guid.split("/");
        let videoUUID = parts[parts.length - 1].split(";")[0];
        let postApi = base + "/api/v1/videos/" + videoUUID + "/comment-threads";
        try {
          await axios.post(postApi, { "text": postBody }, { headers: { "Authorization": `Bearer ` + botToken } })
        } catch (err) {
          console.log("⚡️⚡️\n\n\n\n\n⚡️⚡️ error posting comment", postBody, postApi, err);
        }
      }
    }
    return res.status(200).send();
  })
  router.use('/getchatToken', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting chat room", req.query);
    }
    if (!enableChat) {
      return res.status(503).send();
    }
    let channel = req.query.channel;
    let parts = channel.split('@');
    let customChat;
    if (parts.length > 1) {
      let chatApi = "https://" + parts[1] + "/plugins/lightning/router/getchatroom?channel=" + parts[0];
      try {
        customChat = await axios.get(chatApi);
      } catch {
        console.log("⚡️⚡️hard error getting custom chat room for ", channel, "from", parts[1], chatApi);
      }
      if (customChat) {
        //console.log("⚡️⚡️ returning", customChat.toString(), "for", channel);
        return res.status(200).send(customChat.data);
      }
    }
    let chatRoom;
    if (channel) {
      try {
        chatRoom = await storageManager.getData("irc" + "-" + channel)
      } catch (err) {
        console.log("⚡️⚡️error getting chatroom for ", channel);
      }
    }
    //console.log("⚡️⚡️ Irc chat room", chatRoom);
    if (chatRoom) {
      return res.status(200).send(chatRoom);
    } else {
      return res.status(400).send();
    }
  })
  router.use('/setchattoken', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting chat token", req.query);
    }
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues && req.query.token) {
      let userName = user.dataValues.username;
      if (enableDebug) {
        console.log("███ got authorized peertube user", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("⚡️⚡️⚡️⚡️ user", userName);
      }
      storageManager.storeData("tipToken-" + user.dataValues.username.replace(/\./g, "-"), req.query.token);
      return res.status(200).send();
    }
    return res.status(420).send();
  })
  router.use('/getpoddata', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting pod data", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      console.log("⚡️⚡️ no channel in query", channel, req.query);
      return res.status(400).send("⚡️⚡️ no channel value in request " + req.query);
    }
    let parts = channel.split('@');
    let remotePodData;
    if (parts.length > 1) {
      let remotePodApi = "https://" + parts[1] + "/plugins/lightning/router/getpoddata?channel=" + parts[0];
      try {
        remotePodData = await axios.get(remotePodApi);
      } catch (err) {
        console.log("⚡️⚡️hard error getting custom remote pod data for ", channel, "from", parts[1], remotePodApi, err);
        return res.status(400).send("⚡️⚡️hard error getting custom remote pod data for " + channel + " from " + parts[1] + " using " + remotePodApi + " error " + err);
      }
      if (remotePodData) {
        //console.log("⚡️⚡️ returning", customChat.toString(), "for", channel);
        return res.status(200).send(remotePodData.data);
      }
      console.log("⚡️⚡️ no remote pod data found for", channel);
      return res.status(404).send("⚡️⚡️ no podcast data for " + channel + " on remote system");
    }
    let podData;
    try {
      podData = await storageManager.getData("pod-" + channel.replace(/\./g, "-"));
    } catch (err) {
      console.log("⚡️⚡️error getting pod data for ", channel);
      return res.status(404).send("⚡️⚡️ no podcast data for " + req.query.channel + err);
    }
    if (podData) {
      return res.status(200).send(podData);
    } else {
      console.log("⚡️⚡️ no pod data found for", channel);
      return res.status(404).send("⚡️⚡️ no pod data found for " + channel);
    }
  })
  router.use('/setpoddata', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting podcast data", req.query, req.body);
    }
    //TODO verify authorized user is actual owner of room
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues && req.body) {
      let userName = user.dataValues.username;
      if (enableDebug) {
        console.log("⚡️⚡️⚡️ got authorized peertube user to set pod data ", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("⚡️⚡️⚡️⚡️ user", userName);
      }
      let channel = req.body.channel;
      storageManager.storeData("pod-" + channel.replace(/\./g, "-"), req.body);
      pingPI(channel);
      return res.status(200).send();
    }
    return res.status(420).send();
  })
  router.use('/getwebhooks', async (req, res) => {
    let albyHook = "https://api.getalby.com/webhook_endpoints"
    let body = {};
    let albyData = await storageManager.getData("alby-" + botAccount);
    let response;
    console.log("⚡️⚡️stored data", albyData);
    if (albyData && albyData.access_token) {
      let albyToken = albyData.access_token
      let albyWalletData
      let headers = { headers: { "Authorization": `Bearer ` + albyToken } }
      try {
        response = albyWalletData = await axios.get(albyHook, body, headers)
        return response;
      } catch (err) {
        console.log("\n⚡️⚡️⚡️⚡️error attempting to get webhook\n", err);
        albyWalletData = err.response.status;
      }
      console.log('⚡️⚡️⚡️⚡️ response', response, albyWalletData);
      let newToken = refreshAlbyToken(albyData.refresh_token);
      return res.status(200).send(newToken);
    } else {
      console.log('⚡️⚡️⚡️⚡️ no stored wallet data for bot', botAccount);
    }

  })
  router.use('/createsubscription',async(req,res) => {
    if (!req.body.channel || !req.body.amount || !req.body.type){
      return res.status(420).send ("malformed request");
    }
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (!user || !user.dataValues){
      return res.status(420).send ("unable to confirm authorized user making request");
    }
    let userName;
    if (user && user.dataValues) {
      userName = user.dataValues.username;
      if (enableDebug) {
        console.log("███ got authorized peertube user", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("⚡️⚡️⚡️⚡️ user", userName);
      }
    }
    
    let newSubscription = {
      user: userName,
      channel: req.body.channel,
      amount: req.body.amount,
      type: req.body.type,
      startdate: Date.now(),
      paiddays: 0,
      public: req.body.public,
      pendingconfetti: 0,
    }
    let subscriptions = await storageManager.getData('subscriptions');
    if (!subscriptions){
      subscriptions = [];
    }
    console.log("⚡️⚡️⚡️⚡️ subscriptions plus new one",subscriptions,newSubscription);
    subscriptions.push(newSubscription);
    console.log("⚡️⚡️⚡️⚡️ subscriptions",subscriptions);
    storageManager.storeData("subscriptions", subscriptions);
    sendPatronPayment(userName,req.body.channel,req.body.amount, "first patron payment");
    return res.status(200).send("subscription created");
  })
  router.use('/deletesubscription', async (req, res) => {
    if (!req.query.channel || !req.query.user) {
      return res.status(420).send("malformed request");
    }
    console.log(req.query);
    let user = await peertubeHelpers.user.getAuthUser(res);
    /* need to add capability for mods or channel to delete sub
    let userName = req.query.user;
    if (user && user.dataValues && (user.dataValues.username == req.query.user)) {
      userName = user.dataValues.username;
      if (enableDebug) {
        console.log("███ got authorized peertube user", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("⚡️⚡️⚡️⚡️ user", userName);
      }
    }
    */
    userName = user.dataValues.username;
    let channel = req.query.channel;
    console.log("⚡️⚡️⚡️⚡️ deleting subs",userName,channel);
    let subscriptions = await storageManager.getData('subscriptions');
    let list = [];
    let subs = [];
    //console.log("⚡️⚡️⚡️⚡️ subscriptions",subscriptions);
    if (subscriptions){
      for (var sub of subscriptions){
        //console.log("⚡️⚡️⚡️⚡️ subscription",sub);
        if (userName != sub.user || channel != sub.channel){
          list.push(sub);
          subs.push(sub.channel)
        } else {
          console.log("⚡️⚡️⚡️⚡️ deleted subscription",sub)
        }
      }
      storageManager.storeData("subscriptions", list);
      console.log("⚡️⚡️⚡️⚡️ Saving subscriptions", subs);
      return res.status(200).send("subscription deleted");
    }
    console.log("⚡️⚡️⚡️⚡️ found subscriptions", list,list.length);
  })
  router.use('/editsubscription', async (req, res) => {

  })
  router.use('/getsubscriptions', async (req, res) => {
    if (!req.query.channel || !req.query.user) {
      return res.status(420).send("malformed request");
    }
    let user = await peertubeHelpers.user.getAuthUser(res);
    let userName = req.query.user;
    if (user && user.dataValues && (user.dataValues.username == req.query.user)) {
      userName = user.dataValues.username;
      if (enableDebug) {
        console.log("███ got authorized peertube user", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("⚡️⚡️⚡️⚡️ user", userName);
      }
    }
    let subscriptions = await storageManager.getData('subscriptions');
    let list = [];
    console.log("⚡️⚡️⚡️⚡️ subscriptions",subscriptions);
    if (subscriptions){
      for (var sub of subscriptions){
        console.log("⚡️⚡️⚡️⚡️ sub",sub);
        if (!req.query.channel && req.query.user && (req.query.user == sub.user) && (sub.public || userName)){
          list.push(sub);
        } 
        if (!req.query.user && req.query.channel && (req.query.channel == sub.channel) && (sub.public)) {
          list.push(sub);
        } 
        if ((req.query.user && req.query.channel) && req.query.user == sub.user && req.query.channel == sub.channel && (sub.public || userName)){
          list.push(sub);
        }
      }
    }
    console.log("⚡️⚡️⚡️⚡️ found subscriptions", list,list.length);
    if (list.length>0){
      return res.status(200).send(list);
    } else {
      return res.status(200).send();
    }
  })
  async function saveSplit(uuid, split) {
    try {
      storageManager.storeData("lightningsplit-" + uuid, split);
    } catch {
      console.log("⚡️⚡️failed to store lightning split", uuid, split);
    }
  }
  async function getSavedSplit(uuid) {
    try {
      storedSplitData = await storageManager.getData("lightningsplit-" + uuid);
    } catch {
      console.log("⚡️⚡️ hard failed to get lightning split", uuid);
    }
    var splitTotal = 0;
    let missing = 0;
    if (storedSplitData) {
      for (var split of storedSplitData) {
        if (enableDebug) {
          //console.log("⚡️ split math ", splitTotal, split);
        }
        if (!Number.isInteger(split.split)) {
          //console.log("⚡️ no split value found ", split);
          missing++
        } else {
          splitTotal = splitTotal + split.split;
        }
      }
      if (Number.isInteger(splitTotal) && splitTotal != 100) {
        //console.log("⚡️Split math error!", splitTotal, storedSplitData);
        if (missing == 1) {
          let fixSplit = 100 - splitTotal;
          for (var split of storedSplitData) {
            if (!Number.isInteger(split.split)) {
              split.split = fixSplit;
            }
          }
        }
      }
    }
    if (enableDebug) {
      //console.log("⚡️ returned stored split ", storedSplitData);
    }
    return storedSplitData;
  }
  async function pingPI(pingChannel) {
    let feedApi = base + "/plugins/lightning/router/getfeedid?channel=" + pingChannel;
    let feedId;
    try {
      feedId = await axios.get(feedApi);
      let pingResult;
      if (feedId) {
        pingResult = await axios.get("https://api.podcastindex.org/api/1.0/hub/pubnotify?id=" + feedId.data);
      }
      if (pingResult && pingResult.data) {
        return (pingResult.data);
      }
    } catch {
      console.log("⚡️⚡️hard error when trying ping podcast index ", feedId, feedApi);
    }
  }
  async function getKeysendInfo(address) {
    if (enableDebug) {
      console.log("⚡️⚡️getting keysend info for", address);
    }
    if (!address) { return };
    //TODO need proper function to validate actor address and derived index value
    if ((address.indexOf(`"`) >= 0) || (address.indexOf(">") >= 0) || (address.indexOf("<") >= 0)) {
      return;
    }
    let parts = address.split("@");
    if ((parts.length < 2) || (parts[1].indexOf(".") < 1)) {
      return;
    }
    var storageIndex = "lightning-" + address.replace(/\./g, "-");
    console.log("⚡️⚡️Getting Address", address, storageIndex);
    var storedLightning;
    try {
      storedLightning = await storageManager.getData(storageIndex);
    } catch {
      console.log("⚡️⚡️failed to get stored lighting address", storageIndex);
    }
    if (storedLightning) {
      console.log("⚡️⚡️returning stored lightning address", storageIndex);
      //saveWellKnown(parts[0],storedLightning);
      return storedLightning;
    } else {
      console.log("⚡️⚡️no stored data", storageIndex, storedLightning)
    }
    console.log("⚡️⚡️ getting wallet data", address);
    address = address.toString();
    let walletParts = address.split("@");
    let walletHost = walletParts[1];
    let walletUser = walletParts[0];
    let apiRequest = "https://" + walletHost + "/.well-known/keysend/" + walletUser
    console.log("⚡️⚡️requesting wallet data from provider", apiRequest);
    let walletData;
    try {
      walletData = await axios.get(apiRequest);
    } catch (err) {
      console.log("⚡️⚡️ error attempting to get wallet info", apiRequest, err.message)
      return;
    }
    if (walletData.data.status != "OK") {
      console.log("⚡️⚡️ Error in lightning address data", walletData.data);
      return;
    }
    walletData.data.cache = Date.now();
    console.log("⚡️⚡️ wallet data", walletData.data)
    let whatHappened;
    try {
      whatHappened = await storageManager.storeData(storageIndex, walletData.data);
      saveWellKnown(parts[0], walletData.data);
    } catch {
      console.log("⚡️⚡️failed to store lighting address", storageIndex, walletData.data);
    }
    console.log("⚡️⚡️ stored keysend data", whatHappened, storageIndex, walletData.data);

    return walletData.data;
  }
  async function getLnurlInfo(address) {
    if (enableDebug) {
      console.log("⚡️⚡️getting lnurl info", address);
    }
    if (!address) { return };
    address = address.toString();
    let walletParts = address.split("@");
    let walletHost = walletParts[1];
    let walletUser = walletParts[0];
    let apiRequest = "https://" + walletHost + "/.well-known/lnurlp/" + walletUser
    console.log("⚡️⚡️ requesting lnurlp data from provider", apiRequest);
    let walletData;
    try {
      walletData = await axios.get(apiRequest);
    } catch {
      console.log("⚡️⚡️⚡️⚡️error attempting to get lnurlp info", apiRequest)
      return;
    }
    if (!walletData.data.callback) {
      console.log("⚡️⚡️ Error in lightning address data", walletData.data);
      return;
    }
    return walletData.data;
  }
  async function findLightningAddress(textblock) {
    if (!textblock) {
      return;
    }
    text = textblock.toString();
    const match = text.match(
      /((⚡|⚡️):?|lightning:|lnurl:)\s?([\w-.]+@[\w-.]+[.][\w-.]+)/i
    );
    console.log("⚡️⚡️ match", match);
    if (match) return match[3];
    const matchAlbyLink = text.match(
      /http(s)?:\/\/(www[.])?getalby\.com\/p\/(\w+)/
    );
    console.log("⚡️⚡️ match", matchAlbyLink);
    if (matchAlbyLink) {

      return matchAlbyLink[3] + "@getalby.com";
    }
  }
  async function saveWellKnown(account, keySend) {
    //return;
    const folderName = '/var/www/peertube/storage/well-known/keysend/';
    try {
      if (!fs.existsSync(folderName)) {
        fs.mkdirSync(folderName);
      }
    } catch (err) {
      console.error("⚡️⚡️ problem with well known keysend folder", err, account);
    }
    if (enableDebug) {
      console.error("⚡️⚡️ about to save", account, keySend);
    }
    try {
      fs.writeFileSync(folderName + account, JSON.stringify(keySend));
    } catch (err) {
      console.error("⚡️⚡️ trouble saving the keysend info to peertube folder", err, account);
    }
  }
  async function saveWellKnownSplit(account, splits) {
    //return;
    const folderName = '/var/www/peertube/storage/well-known/keysendsplit/';
    let knownSplits = [];
    for (const split of splits) {
      let newSplit = {};
      newSplit.name = split.name;
      newSplit.split = split.split;
      newSplit.keysend = split.keysend;
      if (split.fee) {
        newSplit.fee = split.fee;
      }
      knownSplits.push(newSplit);
    }
    console.log("⚡️⚡️ new split data", knownSplits, "⚡️⚡️ account:", account, "⚡️⚡️ raw splits", splits);
    try {
      if (!fs.existsSync(folderName)) {
        fs.mkdirSync(folderName);
      }
    } catch (err) {
      console.error("⚡️⚡️ problem with well known keysend split folder", err, account);
    }
    try {
      fs.writeFileSync(folderName + account, JSON.stringify(knownSplits));
    } catch (err) {
      console.error("⚡️⚡️ trouble saving the keysend split info to peertube folder", err, account);
    }
  }
  async function buildFormData(formData, data, parentKey) {
    if (data && typeof data === 'object' && !(data instanceof Date)) {
      Object.keys(data).forEach(key => {
        buildFormData(formData, data[key], parentKey ? `${parentKey}[${key}]` : key);
      });
    } else {
      const value = data == null ? '' : data;

      formData.append(parentKey, value);
    }
  }
  async function getPeerTubeToken(username, password) {
    var clientTokenPath = base + "/api/v1/oauth-clients/local";
    var userTokenPath = base + "/api/v1/users/token";
    try {
      let clientResult = await axios.get(clientTokenPath);
      if (clientResult && clientResult.data) {
        let clientId = clientResult.data.client_id;
        let clientSecret = clientResult.data.client_secret;
        var data = new URLSearchParams();
        data.append('client_id', clientId);
        data.append('client_secret', clientSecret);
        data.append('grant_type', 'password');
        data.append('response_type', 'code');
        data.append('username', username);
        data.append('password', password);
        var postData = data.toString();
        let tokenresponse = await axios.post(userTokenPath, data);
        console.log("token request respoonse", tokenresponse.data);
        bearerToken = tokenresponse.data.access_token;
        return (bearerToken);
      } else {
        console.log("failed to get client token");
      }
    } catch (error) {
      console.log("error in get token", ptuser, ptpassword, ptApi);
      return (-1);
    }
    return;
  }

  async function sendPatronPayment(user,channel,amount, message) {
    if (enableDebug) {
      console.log("⚡️⚡️sending patron payment", user, channel,amount,message);
    }
    let albyData = await storageManager.getData("alby-" + user.replace(/\./g, "-"));
    console.log("⚡️⚡️stored data", albyData);
    if (albyData && albyData.access_token) {
      let albyToken = albyData.access_token
      let albyWalletData
      let boostHeaders = { headers: { "Authorization": `Bearer ` + albyToken } }
      let walletApiUrl = "https://api.getalby.com/payments/keysend/multi"
      let data = {crap:true};
      console.log("⚡️⚡️", data, boostHeaders, walletApiUrl,albyToken)
      var storedSplitData;
      // try getting cached split info with full address
      try {
        storedSplitData = await storageManager.getData("lightningsplit" + "-" + channel);
      } catch {
        console.log("⚡️⚡️hard failed to get lightning split with full address", channel);
        //return;
      }
      let remoteChannel,host,remoteApi;
      if (channel.indexOf('@')>1){
        remoteChannel= channel.split('@')[0];
        host = channel.split('@')[1];
        remoteApi = "https://"+host+"/plugins/lightning/router/getsplit?channel="+remoteChannel;
      }
      console.log("⚡️⚡️ get split info", channel,remoteChannel,host, remoteApi);
      //try for local stored split data
      if (!storedSplitData && host){
        try {
          storedSplitData = await storageManager.getData("lightningsplit" + "-" + remoteChannel);
        } catch {
          console.log("⚡️⚡️hard failed to get lightning split for local channel", channel);
          //return;
        }
        //try plugin API
        if (!storedSplitData){
          try {
            let splitData = await axios.get(remoteApi);
            storedSplitData = splitData.data;
            console.log("⚡️⚡️ remoteApi call", remoteApi,storedSplitData);
          }
          catch {
            console.log("⚡️⚡️hard failed to get lightning split via api", channel,remoteApi);
            //return;
          }
        }
      }  
      
      
      if (!storedSplitData){
        console.log("⚡️⚡️unable to get split bock for channel", channel);
        return;
      }
      // need to generate split blocks data her zoinks.
      let boosts=[];
      for (var payee of storedSplitData){
        console.log("payee",payee);
        let splitAmount = Math.trunc(amount*payee.split/100)
        let msat = splitAmount*1000;
        let totalAmount= amount*1000;
        let boost = {
          "app_name": "PeerTube",
          "value_msat_total": totalAmount, // TOTAL Number of millisats for the payment (all splits together, before fees. The actual number someone entered in their player, for numerology purposes.)
          "value_msat": msat, // Number of millisats for this split payment
          "podcast": channel,
          "action": "auto",
          "name": channel,
          "sender_name": user,
          "message": message

        }
        let keysend;
        if (payee.keysend.customData){
          let customKeyHack = payee.keysend.customData[0].customKey;
          let customValue = payee.keysend.customData[0].customValue;
          keysend = {
            'destination': payee.keysend.pubkey,
            'amount': splitAmount,
            'customRecords': {
              7629169: JSON.stringify(boost),
              [customKeyHack]: customValue,
            }
          };
        } else {
          keysend = {
            'destination': payee.keysend.pubkey,
            'amount': splitAmount,
            'customRecords': {
              7629169: JSON.stringify(boost),
            }
          };
        }
// could not get multipayment working, here's a hack to send the pieces individually
if (albyData && albyData.access_token) {
  let albyToken = albyData.access_token
  let albyWalletData
  let headers = { headers: { "Authorization": `Bearer ` + albyToken } }
  let walletApiUrl = "https://api.getalby.com/payments/keysend"
  console.log("-=--=-=-=-=-testes", data, headers, walletApiUrl)
  dirtyHack=data;
  try {
    albyWalletData = await axios.post(walletApiUrl, keysend, headers)
  } catch (err) {
    console.log("\n⚡️⚡️⚡️⚡️error attempting to send boost\n", err.response.status);
    albyWalletData = err.response.status;
  }
}
//

        boosts.push(keysend);
      }
      return;
      dirtyHack=boosts
      console.log("-=--=-goku-=-=-=-", boosts,boosts[0],boosts[0].custom_records);

      try {
        albyWalletData = await axios.post(walletApiUrl, boosts, boostHeaders)
      } catch (err) {
        console.log("\n⚡️⚡️⚡️⚡️error attempting to send boost\n", err);
        albyWalletData = err.response.status;
      }
      if (albyWalletData == 401) {
        console.log("need to refresh token!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        let albyUrl = 'https://api.getalby.com/oauth/token'
        var form = new URLSearchParams();
        form.append('refresh_token', albyData.refresh_token);
        form.append('grant_type', "refresh_token");
        let refreshHeaders = { auth: { username: client_id, password: client_secret } };
        let response;
        try {
          response = await axios.post(albyUrl, form, refreshHeaders);
        } catch (err) {
          console.log("\n⚡️⚡️⚡️⚡️axios failed to refresh alby token", err, albyUrl, form);
        }
        if (response && response.data) {
          console.log("\n⚡️⚡️⚡️⚡️response to token refreshrequest axios", response.data);
          storageManager.storeData("alby-" + userName.replace(/\./g, "-"), response.data);
          boostHeaders = { headers: { "Authorization": `Bearer ` + response.data.access_token } }
          console.log("-=--=-=-=-=-", data, boostHeaders, walletApiUrl)
          try {
            await axios.post(walletApiUrl, data, boostHeaders)
          } catch (err) {
            console.log("\n⚡️⚡️⚡️⚡️error attempting to send boost with refreshed token\n", err.response.status);
          }
        }
      }
      return;
    } 
  }

  async function refreshAlbyToken(refreshToken) {
    let response;
    console.log("need to refresh token!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    let albyUrl = 'https://api.getalby.com/oauth/token'
    var form = new URLSearchParams();
    form.append('refresh_token', refreshToken);
    form.append('grant_type', "refresh_token");
    let headers = { auth: { username: client_id, password: client_secret } };

    try {
      response = await axios.post(albyUrl, form, headers);
    } catch (err) {
      console.log("\n⚡️⚡️⚡️⚡️axios failed to refresh alby token", err, albyUrl, form);
    }
    return response;
  }
  function jsonToFormData(data) {
    const formData = new URLSearchParams();

    buildFormData(formData, data);

    return formData;
  }
  //need to find a good way to disable get alby auth without erroring out
  var result;
  if (enableAlbyAuth){
    result = registerExternalAuth({
      authName: 'getalby',
      authDisplayName: () => 'Alby Authentication',
      getWeight: () => 60,
      onAuthRequest: async (req, res) => {
        let callbackUrl = base + "/plugins/lightning/router/callback";
        let albyAuthUrl = `https://getalby.com/oauth?client_id=` + client_id + `&response_type=code&redirect_uri=` + callbackUrl + `&scope=account:read%20invoices:create%20invoices:read%20payments:send&state=peertube`;
        console.log("\n⚡️⚡️⚡️⚡️\n\n\n\n trying to authenticate\n\n\n", albyAuthUrl, callbackUrl);
        return res.redirect(albyAuthUrl)
      },
    });
  }
}

async function unregister() {
  return
}
module.exports = {
  register,
  unregister
}

