const axios = require('axios');
const crypto = require('crypto');
const { channel } = require('diagnostics_channel');
const { version } = require('./package.json');
const fs = require('fs');

//const podcastIndexApi = require('podcast-index-api')("UGZJEWXUJARKCBAGPRRF", "EmS3h8yCAWjMMAH5wqEPqUyMKDTDA6tDk5qNPLgn")
async function register({
  registerHook,
  registerSetting,
  getRouter,
  peertubeHelpers,
  settingsManager,
  storageManager,
}) {
  
  registerSetting({
    name: 'lightning-address',
    label: 'Lightning address',
    type: 'input',
    descriptionHTML: 'This is a wallet for both the host split and host donations. Should be keysend compatible so getalby is a good choice',
    private: false
  })
  registerSetting({
    name: 'lightning-split',
    label: 'Requires split for host',
    default: '0',
    type: 'input',
    descriptionHTML: 'This will add a percentage split to any boostagrams or streams sent to videos hosted on this instance',
    private: false
  })
  registerSetting({
    name: 'lightning-tipVerb',
    label: 'Verb to use for tipping',
    type: 'input',
    default: 'Boost',
    descriptionHTML: 'Superchat, Zap, Boostagram, bits, spells, whatever your community would prefer.',
    private: false
  })
    registerSetting({
    name: 'alby-client-id',
    label: 'Alby Api Client ID',
    type: 'input',
    descriptionHTML: 'This is the client ID obtained from Alby. Needed to allow users to authorize payments directly from PeerTube in any browser',
    private: false
  })
  registerSetting({
    name: 'alby-client-secret',
    label: 'Alby API client secret',
    type: 'input-password',
    descriptionHTML: 'The client secret',
    private: true
  })
  registerSetting({
    name: 'irc-enable',
    label: 'Enable IRC chat for channels',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable IRC chat for every channel. Channels can customize the autogenerated room if they have a preferred room',
    private: false
  })
  registerSetting({
    name: 'legacy-enable',
    default:true,
    label: 'Enable legacy fiat tip services',
    type: 'input-checkbox',
    descriptionHTML: 'This will search support and description fields for various third party tip providers',
    private: false
  })
  registerSetting({
    name: 'keysend-enable',
    default: true,
    label: 'Enable Keysend lightning transactions',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable keysend lightning tips, with boostagram meta data',
    private: false
  })
  registerSetting({
    name: 'lnurl-enable',
    default: true,
    label: 'Enable LNURL lightning wallet transactions',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable LNURL lightning wallet transactions, lacks any metadata and is much more data intensive but supports less advanced lighting wallets',
    private: false
  })
  registerSetting({
    name: 'debug-enable',
    label: 'Enable diagnostic log updates',
    type: 'input-checkbox',
    descriptionHTML: 'This will create more extensive logging of program state data both client and server side for finding and resolving errors ',
    private: false
  })
  var base = await peertubeHelpers.config.getWebserverUrl();
  var serverConfig = await peertubeHelpers.config.getServerConfig();
  var hostName = serverConfig.instance.name;
  let lightningAddress = await settingsManager.getSetting("lightning-address");
  if (!lightningAddress) {
    console.log("⚡️⚡️No wallet configured for system");
  }
  let hostSplit = await settingsManager.getSetting("lightning-split");
  if (!hostSplit) {
    hostSplit = 0;
  } else {
    hostSplit = parseInt(hostSplit);
    if (hostSplit < 0 || hostSplit > 100) {
      console.log("⚡️⚡️⚡️⚡️Invalid value for hostsplit", hostSplit);
      hostSplit = 0;
    }
  }
  let enableLegacy = await settingsManager.getSetting("legacy-enable");
  let enableKeysend = await settingsManager.getSetting("keysend-enable");
  let enableLnurl = await settingsManager.getSetting("lnurl-enable");
  let enableDebug = await settingsManager.getSetting("debug-enable");
  //let enableRss = await settingsManager.getSetting("debug-enable");
  let enableChat = await settingsManager.getSettings("irc-enable");
  let client_id=await settingsManager.getSetting("alby-client-id");
  let client_secret=await settingsManager.getSetting("alby-client-secret");
  console.log("⚡️⚡️⚡️⚡️ Lightning plugin started", enableDebug);
  if (enableDebug) {
    console.log("⚡️⚡️ server settings loaded", hostName, base, hostSplit, lightningAddress);
  }
  let hostWalletData = {};
  if (enableKeysend || enableLnurl) {
    if (lightningAddress) {
      hostWalletData.address = lightningAddress;
      hostWalletData.name = lightningAddress;
      if (enableKeysend) {
        let hostKeysendData = await getKeysendInfo(lightningAddress);
        if (!hostKeysendData) {
          console.log("⚡️⚡️⚡️⚡️failed to get system wallet data from provider",lightningAddress);
        } else {
          hostWalletData.keysend = hostKeysendData;
        }
      }
      if ((hostSplit > 0 || hostSplit <= 100) && enableDebug) {
        console.log("⚡️⚡️setting host split to ", hostSplit);
        hostWalletData.split = parseInt(hostSplit);
      }
      hostWalletData.fee = true;
      hostWalletData.name = hostName;
    }
  }
  
  const router = getRouter();
  router.use('/walletinfo', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️Request for wallet info\n", req.query)
    }
    if (!enableLnurl && !enableKeysend) {
      return res.status(503).send("No Lightning services enabled for plug-in");
    }
    let foundLightningAddress;
    if (req.query.address) {
      let keysendData;
      let lnurlData;
      let address = req.query.address;
      if (enableKeysend) {
        keysendData = await getKeysendInfo(address);
      }
      if (enableLnurl) {
        lnurlData = await getLnurlInfo(address);
      }
      if (lnurlData || keysendData) {
        let walletData = {};
        walletData.address = address;
        if (keysendData) {
          walletData.keysend = keysendData;
          if (enableDebug) {
            console.log("⚡️⚡️successfully retrieved keysend data for ", address, keysendData);
          }
        }
        if (lnurlData) {
          walletData.lnurl = lnurlData;
          if (enableDebug) {
            console.log("⚡️⚡️successfully retrieved lnurl data for ", address, lnurlData);
          }
        }
        return res.status(200).send(walletData);
      } else {
        console.log("⚡️⚡️lightning address passed in query does not resolve", address);
        return res.status(400).send("Lightning address"+address+"does not resolve");
      }
    }
    /* Videos and channels should have splits, not single wallets.
    if (req.query.video) {
      //var helpervideo = await peertubeHelpers.videos.loadByIdOrUUID(req.query.video);
      apiCall = base + "/api/v1/videos/" + req.query.video;
      console.log("⚡️⚡️ getting video data", apiCall);
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
      }
      if (videoData) {
        let foundLightningAddress = await findLightningAddress(videoData.data.description + " " + videoData.data.support);
        if (foundLightningAddress) {
          console.log("⚡️⚡️lightning address found in video description [" + foundLightningAddress + ']');
          let keysendData = await getKeysendInfo(foundLightningAddress);
          let lnurlData = await getLnurlInfo(foundLightningAddress);
          if (lnurlData || keysendData) {
            let walletData = {};
            walletData.address = foundLightningAddress;
            if (keysendData) {
              walletData.keysend = keysendData;
              console.log("⚡️⚡️successfully retrieved keysend data for wallet in video", videoData.data.channel.name, keysendData);
              //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
            }
            if (lnurlData) {
              walletData.lnurl = lnurlData;
              console.log("⚡️⚡️successfully retrieved lnurl data for wallet in video", videoData.data.channel.name, lnurlData);
              //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

            }
            return res.status(200).send(walletData);
          } else {
            console.log("⚡️⚡️lightning address in video description does not resolve", foundLightningAddress);
          }
        } else {
          console.log("⚡️⚡️no lightning address found in video description");
        }
      }
    }
    if (req.query.channel) {
      apiCall = base + "/api/v1/video-channels/" + req.query.channel;
      console.log("⚡️⚡️ getting channel data", apiCall);
      let channelData;
      try {
        channelData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️failed to pull information for provided channel id", apiCall);
      }
      if (channelData) {
        let foundLightningAddress = await findLightningAddress(channelData.data.description + " " + channelData.data.support);
        if (foundLightningAddress) {
          console.log("⚡️⚡️lightning address found in channel description [" + foundLightningAddress + ']');
          let keysendData = await getKeysendInfo(foundLightningAddress);
          let lnurlData = await getLnurlInfo(foundLightningAddress);
          if (lnurlData || keysendData) {
            let walletData = {};
            walletData.address = foundLightningAddress;
            if (keysendData) {
              walletData.keysend = keysendData;
              console.log("⚡️⚡️successfully retrieved keysend data for wallet in channel", channelData.data.name, keysendData);
            }
            if (lnurlData) {
              walletData.lnurl = lnurlData;
              console.log("⚡️⚡️successfully retrieved lnurl data for wallet in channel", channelData.data.name, lnurlData);
            }
            return res.status(200).send(walletData);
          } else {
            console.log("⚡️⚡️lightning address in channel description does not resolve", foundLightningAddress);
          }
        } else {
          console.log("⚡️⚡️no lightning address found in channel description");
        }
      }
    }
    */
    if (req.query.account) {
      var storedWallet
      try {
        storedWallet = await storageManager.getData("lightning-" + req.query.account.replace(/\./g, "-"));
      }catch (err) {
        console.log ("⚡️⚡️failed to get stored lightning address for account",req.query.account,err);
      }
      if (storedWallet) {
        if (enableDebug){
          console.log("⚡️⚡️ successfully found stored wallet data for account", req.query.account, storedWallet);
        }
        if (storedWallet.status === 404) {
          console.log("⚡️⚡️404 not found error, cache dates", storedWallet.cache, Date.now() - storedWallet.cache);
        } else {
          return res.status(200).send(storedWallet);
        }
      } else {
        if (enableDebug) {
          console.log("⚡️⚡️no stored wallet for account", req.query);
        }
      }
      let parts = req.query.account.split("@")
      if (parts.length > 1) {
        apiCall = "https://" + parts[1] + "/api/v1/accounts/" + parts[0];
      } else {
        apiCall = base + "/api/v1/accounts/" + req.query.account;
      }
      let accountData;
      try {
        accountData = await axios.get(apiCall);
      } catch (err){
        console.log("⚡️⚡️hard failure pulling acount information", apiCall,err);
      }
      if (!accountData) {
        //hack for mastardon's lame api
        apiCall = "https://" + parts[1] + "/api/v1/accounts/lookup?acct=" + parts[0]
        try {
          accountData = await axios.get(apiCall);
        } catch (err){
          console.log("⚡️⚡️errored trying to pull information from mastodon", apiCall,err);
        }
      }
      if (accountData) {
        let account = accountData.data
        if (enableDebug) {
          console.log("⚡️⚡️account to search for address", account);
        }
        if (account.description) {
          foundLightningAddress = await findLightningAddress(account.description);
        }
        if (!foundLightningAddress && account.fields) {
          for (var field of account.fields) {
            if (field.name === "Lightning Address" || field.name === "LUD16") {
              foundLightningAddress = field.value;
            }
          }
        }
        if (!foundLightningAddress && account.note) {
          foundLightningAddress = await findLightningAddress(account.note);
        }
        if (foundLightningAddress) {
          let keysendData
          if (enableKeysend) {
            keysendData = await getKeysendInfo(foundLightningAddress);
          }
          let lnurlData;
          if (enableLnurl) {
            lnurlData = await getLnurlInfo(foundLightningAddress);
          }
          if (lnurlData || keysendData) {
            let walletData = {};
            walletData.address = foundLightningAddress;
            if (keysendData) {
              walletData.keysend = keysendData;
              if (req.query.account.indexOf("@") < 0) {
                if (enableDebug) {
                  console.log("attempting to save keysend info", req.query.account)
                }
                //saveWellKnown(req.query.account, keysendData);
              }
            }
            if (lnurlData) {
              walletData.lnurl = lnurlData;
            }
            walletData.cache = Date.now();
            if (enableDebug) {
              console.log("⚡️⚡️preparing to save and return found wallet info", req.query.account, walletData.address);
            }
            try {
              storageManager.storeData("lightning-" + req.query.account.replace(/\./g, "-"), walletData);
            }catch {
              console.log ("⚡️⚡️failed to store lighting address",req.query.account,walletData);
            }
            return res.status(200).send(walletData);
          } else {
            console.log("⚡️⚡️ no lightning address support enabled", foundLightningAddress, req.query);
          }
        }
        let notFound = { status: 404 };
        notFound.cache = Date.now();
        try {
          storageManager.storeData("lightning-" + req.query.account.replace(/\./g, "-"), notFound);
        } catch {
          console.log ("⚡️⚡️hard error storing address not found",req.query.account,notFound);
        }
        return res.status(400).send();
      }
    }
  })
  router.use('/podcast2', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️ podcast2 request ⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️", req.query);
    }
    /*
    if (!enableRss) {
      return res.status(503).send();
    }
    */
    if (req.query.channel == undefined) {
      console.log("⚡️⚡️no channel requested", req.query);
      return res.status(400).send();
    }
    let channel = req.query.channel
    let instance, instanceUrl;
    if (channel.indexOf("@") > 1) {
      let channelParts = channel.split("@");
      instance = channelParts[1];
      instanceUrl = "https://" + instance;
      channel = channelParts[0];
    } else {
      instanceUrl = base;
    }
    console.log("⚡️⚡️ channel", channel, "instance", instance, instanceUrl);
    let apiUrl = instanceUrl + "/api/v1/video-channels/" + channel;
   // let mirrorUrl = instanceUrl + `/api/v1/server/redundancy/videos?target=my-videos`;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
      //console.log("want some ",await axios.get(mirrorUrl).data);
    } catch {
      console.log("⚡️⚡️⚡️⚡️unable to load channel info", apiUrl);
      return res.status(400).send();
    }
    console.log("⚡️⚡️loaded channel data from", apiUrl);
    let rssUrl = instanceUrl + "/feeds/videos.xml?videoChannelId=" + channelData.data.id;
    let rssData;
    try {
      rssData = await axios.get(rssUrl)
    } catch {
      console.log("⚡️⚡️unable to load rss feed for channel", rssUrl);
      return res.status(400).send();
    }
    console.log("⚡️⚡️loaded rss feed from", rssUrl);
    apiUrl = base + "/plugins/lightning/router/getsplit?channel=" + req.query.channel;
    let lightningData
    let splitData;
    try {
      splitData = await axios.get(apiUrl);
    } catch {
      console.log("⚡️⚡️unable to load lightning wallet info for channel", apiUrl);
      splitData = { data: {} };
    }
    console.log("⚡️⚡️loaded wallet information for channel", apiUrl, splitData.data.length);
    /*let pubKey, tag, customKey, customValue;
    if (lightningData.data.keysend) {
      pubKey = lightningData.data.keysend.pubkey;
      tag = lightningData.data.keysend.tag;
      if (lightningData.data.keysend.customData[0]) {
        customKey = lightningData.data.keysend.customData[0].customKey;
        customValue = lightningData.data.keysend.customData[0].customValue;
      }
    } else {
      console.log("no keysend data available for wallet")
    }
    */
    let splits = splitData.data;
    let keysend = false;
    for (let s in splits) {
      console.log("checking splits", keysend, splits[s]);
      if (splits[s].keysend) {
        keysend = true;
      }
    }
    console.log("⚡️⚡️keysend", keysend, split);
    let channelGuid;
    apiUrl = base + "/plugins/lightning/router/getchannelguid?channel=" + req.query.channel;
    try {
      let guidData = await axios.get(apiUrl);
      if (guidData && guidData.data) {
        console.log("⚡️⚡️channel guid", guidData.data);
        channelGuid = guidData.data;
      }
    } catch {
      console.log("⚡️⚡️unable to load channel guid", apiUrl);
    }
    //TODO figure out how to get info for livechat plugin as well
    let chatInfo;
    apiUrl = base + "/plugins/matrixchat/router/getchatjson?channel=" + req.query.channel;
    try {
      let chatData = await axios.get(apiUrl);
      if (chatData && chatData.data) {
        console.log("⚡️⚡️chat info", chatData.data);
         chatInfo = chatData.data;
      }
    } catch {
      console.log("⚡️⚡️unable to load chat info", apiUrl);
    }
    let counter = 0;
    let fixed = "";
    let spacer = "";
    let rss = rssData.data;
    let lines = rss.split('\n');
    let newLine = "";
    let altLine = "";
    let resolution = "";
    let displayName = channelData.data.displayName;
    for (var line of lines) {
      counter++;
      //console.log(counter,line);
      if (counter == 2) {
        line = `<rss version="2.0" xmlns:podcast="https://github.com/Podcastindex-org/podcast-namespace/blob/main/docs/1.0.md" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">`
      }
      if (line.indexOf("<enclosure") > 0) {
        continue;
      }
      if ((line.indexOf("media:content") > 0) && (line.indexOf('height="0"') < 1)) {
        continue;
      }

      if ((line.indexOf("media:content") > 0)) {
        cut = line.substring(line.indexOf('fileSize') + 9, line.indexOf("framerate"));
        //console.log(cut);
        let hack = cut.split("/");
        for (var piece in hack) {
          console.log("part", piece, hack[piece]);
        }
        var apiCall = base + "/api/v1/videos/" + hack[4];
        let video;
        console.log("⚡️⚡️api call", apiCall);
        try {
          video = await axios.get(apiCall)
        } catch {
          console.log("⚡️⚡️error trying to get video data to build alternate enclosures");
        }
        if (video) {
          let nodes = video.data.streamingPlaylists[0].redundancies;
          if (nodes.length > 0) {
            let hackLength = hack[0].split(' ');
            altLine = '\n' + spacer + `<podcast:alternateEnclosure type="video/mp4" default="true" length=` + hackLength[0] + ">";
            for (var node in nodes) {
              altLine = altLine + '\n' + spacer + `\t<podcast:source uri="` + nodes[node].baseUrl + '/' + hack[5] + `/>"`
            }
            altLine = altLine + '\n' + spacer + `</podcast:alternateEnclosure>`
            // fixed = fixed + altLine;
          }

        }
        newLine = '<enclosure type="video/mp4" length=' + cut + "/>";
        //console.log(newLine);
        //peers = video
      }
      if (line.indexOf('atom:link') > 0) {
        spacer = (line.substring(0, line.indexOf('<')));
        //let atompart = line.split("");
        line=spacer+`<atom:link href="`+base+req.originalUrl+`" rel="self" type="application/rss+xml"/>`;
        fixed = fixed + "\n" + spacer + '<podcast:locked owner="' + req.query.channel + '">no</podcast:locked>';
        fixed = fixed + '\n' + spacer + '<itunes:owner>\n'
        //fixed = fixed + spacer + '\t<itunes:email>' + 'errhead@gmail.com' + '</itunes:email>\n'
        fixed = fixed + spacer + '\t<itunes:name>' + channel + '</itunes:name>\n'
        fixed = fixed + spacer + '</itunes:owner>\n';
        fixed = fixed + spacer + '<itunes:author>' + displayName + '</itunes:author>\n'
        if (keysend) {
          fixed = fixed + spacer + '<podcast:value type="lightning" method="keysend" suggested="0.00000000069">\n';
          for (var split of splits) {
            if (split.keysend) {
              fixed = fixed + spacer + '\t<podcast:valueRecipient name="' + split.name + '" type="node" address="' + split.keysend.pubkey + '"';
              if (split.keysend.customData) {
                let cv = split.keysend.customData[0].customValue
                let ck = split.keysend.customData[0].customKey;
                if (cv) {
                  fixed = fixed + ' customValue="' + cv + '"'
                }
                if (ck) {
                  fixed = fixed + ' customKey="' + ck + '"'
                }
              }
              if (split.fee){
                fixed = fixed + ` fee="true" `
              }
              fixed = fixed + ` split="` + split.split + `" />\n`;

            }
          }
          fixed = fixed + spacer + '</podcast:value>\n';
        } else {
          console.log("⚡️⚡️no pubkey value");
        }
        if (channelGuid) {
          fixed = fixed + spacer + '<podcast:guid>' + channelGuid + '</podcast:guid>\n'
        } else {
          console.log("⚡️⚡️no channel guid available");
        }
        if (chatInfo){
          fixed = fixed+spacer+`<podcast:chat\n`;
          if (chatInfo.protocol){
            fixed = fixed+spacer+`\tprotocol="`+chatInfo.protocol+`"\n`;
          }
          if (chatInfo.accountId){
            fixed = fixed+spacer+`\taccountId="`+chatInfo.accountId+`"\n`;
          }
          if (chatInfo.server){
            fixed = fixed+spacer+`\tserver="`+chatInfo.server+`"\n`;
          }
          if (chatInfo.space){
            fixed = fixed+spacer+`\tspace="`+chatInfo.space+`"\n`;
          }
          if (chatInfo.embedUrl){
            fixed = fixed+spacer+`\tembedUrl="`+chatInfo.embedUrl+`"\n`;
          }
          fixed=fixed+spacer+`/>`
        } 
      }
      if (line.indexOf("<url>") > 0) {
        spacer = (line.substring(0, line.indexOf('<')));
        let avatar = channelData.data.avatar
        if (avatar != null) {
          line = spacer + '<url>' + instanceUrl + avatar.path + '</url>';
        }
      }
      if (line.indexOf("media:thumbnail") > 0) {
        spacer = (line.substring(0, line.indexOf('<')));
        let cut = line.substring(line.indexOf('url=') + 5);
        cut = cut.substring(0, cut.indexOf('"'));

        fixed = fixed + "\n" + spacer + '<itunes:image>' + cut + '</itunes:image>';
      }
      if (line.indexOf('media:title') > 0) {
        spacer = (line.substring(0, line.indexOf('<')));
        fixed = fixed + '\n' + spacer + newLine + altLine;
      }
      if (line.indexOf('guid>') > 0) {
        spacer = (line.substring(0, line.indexOf('<')));

        let cut = line.substring(line.indexOf('<guid>') + 6);
        cut = cut.substring(0, cut.indexOf('</guid>'));
        console.log("⚡️⚡️cut", cut);
        urlPieces = cut.split("/");
        let id = urlPieces[urlPieces.length - 1];
        console.log("⚡️⚡️id", id);
        apiUrl = base + "/plugins/lightning/router/getchannelguid?channel=" + req.query.channel;
        let captionApi = base + "/api/v1/videos/" + id + "/captions";
        let captionResult;
        try {
          captionResult = await axios.get(captionApi);
        } catch (err) {
          console.log("⚡️⚡️failed requesting transcript data", err);
        }

        //TODO go through all captions available and add with language
        if (captionResult && captionResult.data && captionResult.data.total > 0) {
          //console.log("caption result", captionResult.data);
          captionPath = instanceUrl + captionResult.data.data[0].captionPath
          captionLanguage = captionResult.data.data[0].language.id;
          if (captionPath.indexOf("vtt") > 1) {
            fixed = fixed + "\n" + spacer + `<podcast:transcript url="` + captionPath + `" language="` + captionLanguage + `" type="text/vtt" rel="captions"/>`;
          } else {
            fixed = fixed + "\n" + spacer + `<podcast:transcript url="` + captionPath + `" language="` + captionLanguage + `" type="text/plain" rel="captions"/>`;

          }

        }
        //fixed = fixed + "\n" + spacer + '<podcast:socialInteract protocol="activitypub" uri="' + cut + '"/>';
        //console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️ user account", channelData.data.ownerAccount);
        //fixed = fixed + "\n" + spacer + '<podcast:socialInteract protocol="activitypub" uri="https://lawsplaining.peertube.biz/videos/watch/9b31d490-7c3b-4fab-81e6-302cf48320b4" accountId="@' + channelData.data.ownerAccount.name + '" accountUrl="' + channelData.data.ownerAccount.url + '"/>';
        fixed = fixed + "\n" + spacer + '<podcast:socialInteract protocol="activitypub" uri="' + cut + '" accountId="@' + channelData.data.ownerAccount.name + '" accountUrl="' + channelData.data.ownerAccount.url + '"/>';

      }

      if (counter>1){
        fixed = fixed + '\n' + line;
      } else {
        fixed = line;
      }
    }
    res.status(200).send(fixed);
    //console.log(rssResult.data);
    return;

  })
  router.use('/setWallet', async (req, res) => {
    if (enableDebug){
       console.log("⚡️⚡️wallet setting request",req.query);
    }
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues && req.query.address) {
      let userName = user.dataValues.username;
      if (enableDebug){
         console.log("███ got authorized peertube user",user.dataValues.username);
      }
      if (enableDebug){
        console.log("⚡️⚡️⚡️⚡️ user",userName);
      }
      storageManager.storeData("lightning-" + user.dataValues.username.replace(/\./g, "-"),req.query.address);
      return res.status(200).send(req.query.address);
    }
    return res.status(420).send();
    /* disabling pubkey/custom value for now
    if (!req.query.key) {
      return res.status(400).send("missing key");
    }
    if (req.query.address) {
      let walletInfo = getKeysendInfo(req.query.address);
      if (walletInfo) {
        let lightning = {};
        lightning.address = req.query.address;
        lightning.data = newData
        console.log("⚡️⚡️saving wallet data", req.query.key, lightning);
        //storageManager.storeData("lightning" + "-" + req.query.key, lightning);
        return res.status(200).send(lightning);
      } else {
        console.log("failed to get wallet info for provided address", req.query.address);
        return res.status(400).send();
      }
    }

    if (!req.query.pubkey) {
      return res.status(400).send("missing pubkey");
    }
    if (!req.query.tag) {
      return res.status(400).send("missing tag");
    }
    let newData = {
      status: "OK",
      tag: req.query.tag,
      pubkey: req.query.pubkey,
    }

    if (req.query.customvalue) {
      if (!req.query.customkey) {
        req.query.customkey = "696969";
      }
      let customData = {
        customKey: req.query.customkey,
        customValue: req.query.customvalue,
      }
      let customDataArray = [];
      customDataArray.push(customData);
      newData.customData = customDataArray;
    }
    let lightning = {};
    lightning.data = newData
    console.log("⚡️⚡️saving wallet data", req.query.key, lightning);
    //storageManager.storeData("lightning" + "-" + req.query.key, lightning);
    return res.status(200).send(lightning);
    */
  })
  router.use('/getinvoice', async (req, res) => {
    //  console.log(req);
    if (enableDebug) {
      console.log("⚡️⚡️ getting lnurl invoice", req.query);
    }
    if (!enableLnurl) {
      return res.status(503).send();
    }
    let message = encodeURIComponent(req.query.message);
    let invoiceRequest = req.query.callback + "?amount=" + req.query.amount + "&comment=" + message;
    console.log("⚡️⚡️invoice request url", invoiceRequest);
    let result;
    try {
      result = await axios.get(invoiceRequest);
    } catch (err) {
      console.log("⚡️⚡️failed to get invoice", err);
      return res.status(400).send(err);
    }
    console.log("⚡️⚡️ Invoice data",result.data);
    return res.status(200).send(result.data);
  })
  router.use('/getfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting feed id", req.query);
    }
    let channel = req.query.channel;
    if (!channel){
      return res.status(420).send("no channel in feed id request");
    }
    let feed;
    let parts = channel.split('@');
    if (parts.length > 1) {
      let feedApi = "https://" + parts[1] + "/plugins/lightning/router/getfeedid?channel=" + parts[0];
      try {
        feed = await axios.get(feedApi);
      } catch {
        console.log("⚡️⚡️hard error getting feed id for ", channel, "from", parts[1], feedApi);
      }
      if (feed && feed.data) {
        console.log("⚡️⚡️ returning", feed.data, "for", channel,feed.data.toString());
        return res.status(200).send(feed.data.toString());
      }
      return res.status(420).send("remote channel returned no feed id");
    }
    if (channel) {
      try {
        feed = await storageManager.getData("podcast" + "-" + channel)
      } catch (err) {
        console.log("⚡️⚡️error getting feedid", channel);
      }
    }
    console.log("⚡️⚡️ feed", feed);
    if (feed) {
      return res.status(200).send(feed.toString());
    } else {
      return res.status(400).send("no feed id found for requested channel");
    }
  })
  router.use('/setfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting feed id", req.query);
    }
    let channel = req.query.channel;
    let feedID = req.query.feedid;
    if (channel) {
      try {
        await storageManager.storeData("podcast" + "-" + channel, feedID);
        return res.status(200).send();
      } catch (err) {
        console.log("⚡️⚡️ error storing feedid", channel,feedID);
        return res.status(400).send();
      }
    }
  })
  router.use('/getchatroom', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting chat room", req.query);
    }
    if (!enableChat) {
      return res.status(503).send();
    }
    let channel = req.query.channel;
    let parts = channel.split('@');
    let customChat;
    if (parts.length > 1) {
      let chatApi = "https://" + parts[1] + "/plugins/lightning/router/getchatroom?channel=" + parts[0];
      try {
        customChat = await axios.get(chatApi);
      } catch {
        console.log("⚡️⚡️hard error getting custom chat room for ", channel, "from", parts[1], chatApi);
      }
      if (customChat) {
        console.log("⚡️⚡️ returning", customChat.toString(), "for", channel);
        return res.status(200).send(customChat.data);
      }
    }
    let chatRoom;
    if (channel) {
      try {
        chatRoom = await storageManager.getData("irc" + "-" + channel)
      } catch (err) {
        console.log("⚡️⚡️error getting chatroom for ", channel);
      }
    }
    console.log("⚡️⚡️ Irc chat room", chatRoom);
    if (chatRoom) {
      return res.status(200).send(chatRoom);
    } else {
      return res.status(400).send();
    }
  })
  router.use('/setchatroom', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting chatroom", req.query);
    }
    if (!enableChat) {
      return res.status(503).send();
    }
    let channel = req.query.channel;
    let chatroom = req.query.chatroom;
    let parts = channel.split('@');
    if (parts.length > 1) {
      return res.status(503).send();
    }
    if (channel) {
      try {
        await storageManager.storeData("irc" + "-" + channel, chatroom);
        return res.status(200).send(chatroom);
      } catch (err) {
        console.log("⚡️⚡️ error getting chatroom", channel,chatroom);
      }
    }
    return res.status(400).send();
  })
  router.use('/getitemid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting item id", req.query);
    }
    let uuid = req.query.uuid;
    let item;
    if (uuid) {
      try {
        item = await storageManager.getData("podcast" + "-" + uuid);
      } catch (err) {
        console.log("⚡️⚡️ error getting stored itemid", uuid);
      }
    }
    if (item) {
      return res.status(200).send(item.toString());
    } else {
      var apiCall = base + "/api/v1/videos/" + uuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
      }
      if (videoData) {
        let videoHost = videoData.data.channel.host
        if ("https://" + videoHost != base) {
          let hostApi = "https://" + videoHost + "/plugins/lightning/router/getitemid?uuid=" + uuid;
          let hostItemId;
          try {
            hostItemId = await axios.get(hostApi);
          } catch {
            console.log("⚡️⚡️failed to pull item ID from video host", hostApi);
          }
          if (hostItemId) {
          try {
            await storageManager.storeData("podcast" + "-" + uuid, hostItemId);
          } catch {
            console.log ("⚡️⚡️failed to get stored lighting address",uuid, hostItemId);
          }
            return res.status(200).send(hostItemId.data.toString());
          } else {
            console.log("⚡️⚡️ No id provided by hosting instance");
          }
        }
        let channel = videoData.data.channel.name;
        let feedApi = base + "/plugins/lightning/router/getfeedid?channel=" + channel;
        try {
          feedId = await axios.get(feedApi);
        } catch {
          console.log("⚡️⚡️ error when tring to get feed id ", feedApi);
          return res.status(404).send();
        }
        /*if (feedId) {
          console.log("⚡️⚡️got feed id", feedId.data);
          let podcastIndexId = await podcastIndexApi.episodesByFeedId(feedId.data);
          let finalItemId;
          //let easy = podcastIndexApi.custom("/episodes/byguid",)
          if (podcastIndexId) {

            for (var episode in podcastIndexId.items) {
              //console.log("here it is boys:",podcastIndexId.items[episode].id,episode);
              //console.log(podcastIndexId.items[episode].guid, videoData.data.shortUUID);
              if (podcastIndexId.items[episode].guid.indexOf(videoData.data.shortUUID) > 1) {
                console.log("⚡️⚡️matching video found", episode, podcastIndexId.items[episode].id, podcastIndexId.items[episode].name);
                finalItemId = podcastIndexId.items[episode].id;
                //return res.status(200).send(podcastIndexId.toString());
              } else {
                //console.log("no matching video,", episode, podcastIndexId.items[episode].title);
              }
            }
            if (finalItemId) {
              console.log("⚡️⚡️obtained id from podcast index", uuid, finalItemId);
              try {
                await storageManager.storeData("podcast" + "-" + uuid, podcastIndexId, finalItemId);
              } catch {
                console.log ("⚡️⚡️failed to get stored podcast ",uuid, podcastIndexId, finalItemId);
              }
              return res.status(200).send(finalItemId);
            }
          } else {
            console.log("⚡️⚡️error getting item id from podcast index", feedId);
          }
        } else {
          console.log("⚡️⚡️can't get video from host");
          return res.status(400).send();
        }
        */
      }
      console.log("⚡️⚡️no videodata available", apiCall);
      return res.status(400).send();
    }
  })
  router.use('/getlnurl', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting lnurl info", req.query);
    }
    if (!enableLnurl) {
      return res.status(503).send();
    }
    let result = getLnurlInfo(req.query.address);
    if (result) {
      return res.status(200).send(result);
    } else {
      return res.status(400).send();
    }
  })
  router.use('/setitemid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting item id", req.query.uuid);
    }
    let uuid = req.query.uuid;
    let itemID = req.query.itemid;
    if (uuid) {
      try {
        await storageManager.storeData("podcast" + "-" + uuid, itemID);
        return res.sendStatus(200);
      } catch (err) {
        console.log("⚡️⚡️error setting item id", uuid,itemID);
        return res.sendStatus(400).send();
      }
    }
  })
  router.use('/getchannelguid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting channel guid", req.query);
    }
    let channel = req.query.channel;
    let channelGuid;
    if (channel) {
      try {
        channelGuid = await storageManager.getData("channelguid" + "-" + channel)
      } catch (err) {
        console.log("⚡️⚡️ error getting channel guid", channel);
        return res.status(400).send();
      }
    }
    if (channelGuid) {
      return res.status(200).send(channelGuid);
    } else {
      channelGuid = crypto.randomUUID();
      if (channelGuid) {
      try {
        await storageManager.storeData("channelguid" + "-" + channel, channelGuid);
      } catch {
        console.log ("⚡️⚡️failed to get stored guid",channel, channelGuid);
      }
      return res.status(200).send(channelGuid);
      } else {
        console.log("⚡️⚡️ error attempting to generate channel guiid");
        return res.status(400).send();
      }
    }
  })
  router.use('/getsplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️Request for split info\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send();
    }
    var storedSplitData;
    if (req.query.video) {
      var storedSplitData = await storageManager.getData("lightningsplit" + "-" + req.query.video);
      console.log("⚡️⚡️retrieved split info", req.query.video, storedSplitData);
      if (storedSplitData) {
        for (var splitSlot in storedSplitData){
          if (storedSplitData[splitSlot].fee && storedSplitData[splitSlot].address != hostWalletData.address){
            console.log("⚡️ old information on host split, updating",storedSplitData[splitSlot].address,storedSplitData[splitSlot].split);
            storedSplitData[splitSlot] = hostWalletData;
            await storageManager.storeData("lightningsplit" + "-" + req.query.video,storedSplitData,);
            console.log("⚡️ updated host split",storedSplitData[splitSlot].address,storedSplitData[splitSlot].split);
          }
        }        
        console.log("⚡️⚡️returning video split info", req.query.video,storedSplitData.length);
        return res.status(200).send(storedSplitData);
      }
      let parts
      if (req.query.channel && req.query.channel.indexOf("@")>0 ) {
        parts = req.query.channel.split("@");
        var apiCall = "https://" + parts[1] + "/plugins/lightning/router/getsplit?video=" + req.query.video;
        let remoteSplit;
        try {
          remoteSplit = await axios.get(apiCall);
        } catch {
          console.log("⚡️⚡️unable to fetch remote split data", apiCall);
        }
        if (remoteSplit) {
          if (enableDebug) {
            console.log("⚡️⚡️returning remote split", apiCall, remoteSplit.data);
          }
          return res.status(200).send(remoteSplit.data);
        }
      }
      console.log("⚡️⚡️stored split data not found for video",req.query.video);
      if (!req.query.channel) {
        console.log("⚡️⚡️base", base);
        var apiCall = base + "/api/v1/videos/" + req.query.video;
        console.log("⚡️⚡️ getting video data for video", apiCall);
        let videoData;
        try {
          videoData = await axios.get(apiCall);
        } catch {
          console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
        }
        if (videoData) {
          console.log("⚡️⚡️videodata for",req.query.video, videoData.data);
          let videoChannel = videoData.data.channel.name;
          let videoHost = "https://" + videoData.data.channel.host;
          console.log("⚡️⚡️ Video data ", videoChannel, videoHost,base);
         
          try {
            storedSplitData = await storageManager.getData("lightningsplit" + "-" + videoChannel);
          } catch {
            console.log ("⚡️⚡️failed to get lightning split",videoChannel);
          } 
          console.log("⚡️⚡️retrieved chaNNEL split info for video", videoChannel, storedSplitData.length);
          if (storedSplitData) {
            console.log("⚡️⚡️returning stored channel split for request video", req.query.channel,videoChannel,req.query.video,storedSplitData);
            //TODO save video split info?
            return res.status(200).send(storedSplitData);
          }
          
          if (videoHost != base) {
            remoteWalletApi = videoHost + "/plugins/lightning/router/getsplit?channel=" + channel.name;
            let remoteSplitData;
            try {
              remoteSplitData = await axios.get(remoteWalletApi);
            } catch {
              console.log("failed to pull remote split info", apiCall);
            }
            if (remoteSplitData) {
              return res.status(200).send(remoteSplitData);
            }
          }
          //let split
          console.log("⚡️⚡️channels",videoData.data.channel);
          let foundLightningAddress = await findLightningAddress(videoData.data.description + " " + videoData.data.support + " " + videoData.data.channel.description + " " + videoData.data.channel.support + " " + videoData.data.account.description);
          if (foundLightningAddress) {
            console.log("⚡️⚡️lightning address found in video description [" + foundLightningAddress + ']');
            let keysendData = await getKeysendInfo(foundLightningAddress);
            let lnurlData = await getLnurlInfo(foundLightningAddress);
            if (lnurlData || keysendData) {
              let walletData = {};
              walletData.address = foundLightningAddress;
              if (keysendData) {
                walletData.keysend = keysendData;
                console.log("⚡️⚡️successfully retrieved keysend data for wallet in video", videoData.data.channel.name, keysendData);
                //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
              }
              if (lnurlData) {
                walletData.lnurl = lnurlData;
                console.log("⚡️⚡️successfully retrieved lnurl data for wallet in video", videoData.data.channel.name, lnurlData);
                //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

              }
              if (walletData.keysend) {
                if (walletData.address.indexOf("fountain.fm") > 0) {
                  walletData.keysend = null;
                }
              }
              var splitData = new Array();
              walletData.split = 100;
              splitData.push(walletData);
              if (hostWalletData && (videoHost == base)) {
                splitData[0].split = 100 - hostWalletData.split;
                splitData.push(hostWalletData);
              }
              try {
                await storageManager.storeData("lightningsplit" + "-" + req.query.video, splitData);
              } catch {
                console.log ("⚡️⚡️failed to store lightning split",req.query.video,splitData);
              } 
              return res.status(200).send(splitData);
            } else {
              console.log("⚡️⚡️lightning address in video description does not resolve", foundLightningAddress);
            }
          } else {
            console.log("⚡️⚡️no lightning address found in video description");
          }
        }
      }
      //console.log("unable to find any split info in video data");
      //return res.status(400).send();
    }
     if (req.query.channel) {
      var storedSplitData;
      try {
        storedSplitData = await storageManager.getData("lightningsplit" + "-" + req.query.channel);
      } catch {
        console.log ("⚡️⚡️failed to get lightning split",req.query.channel);
      } 
      if (storedSplitData) {
        for (var splitSlot in storedSplitData){
          if (storedSplitData[splitSlot].fee){
            console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️",storedSplitData[splitSlot].address,storedSplitData[splitSlot].split);
            storedSplitData[splitSlot] = hostWalletData;
            console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️",storedSplitData[splitSlot].address,storedSplitData[splitSlot].split);
           }
        } 
        return res.status(200).send(storedSplitData);
      }
      let remoteHost, remoteChannel;
      if (req.query.channel.indexOf("@") > 1) {
        let channelParts = req.query.channel.split("@");
        remoteHost = channelParts[1];
        remoteChannel = channelParts[0];
      }
      var apiCall;
      if (remoteHost) {
        console.log("⚡️⚡️getting remote data");
        apiCall = "https://" + remoteHost + "/plugins/lightning/router/getsplit?channel=" + remoteChannel;
        let remoteSplit;
        try {
          remoteSplit = await axios.get(apiCall);
        } catch {
          console.log("⚡️⚡️unable to fetch remote split data", apiCall);
        }
        if (remoteSplit) {
          if (enableDebug) {
            console.log("⚡️⚡️returning remote split", apiCall, remoteSplit.data);
          }
          return res.status(200).send(remoteSplit.data);
        }
      }
      apiCall = base + "/api/v1/video-channels/" + req.query.channel;
      let channelData;
      try {
        channelData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️failed to pull information for provided channel id", apiCall);
      }
      if (channelData) {
        //console.log("channeldata",channelData);
        let foundLightningAddress = await findLightningAddress(channelData.data.description + " " + channelData.data.support);
        if (foundLightningAddress) {
          let keysendData, lnurlData;
          if (enableKeysend) {
            keysendData = await getKeysendInfo(foundLightningAddress);
          }
          if (enableLnurl) {
            lnurlData = await getLnurlInfo(foundLightningAddress);
          }
          if (lnurlData || keysendData) {
            let walletData = {};
            walletData.address = foundLightningAddress;
            if (keysendData) {
              walletData.keysend = keysendData;
            }
            if (lnurlData) {
              walletData.lnurl = lnurlData;
            }
            var splitData = new Array;

            walletData.split = 100;
            splitData.push(walletData);
            if (hostWalletData) {
              splitData[0].split = 100 - hostWalletData.split;
            }
            splitData.push(hostWalletData);
            try {
              await storageManager.storeData("lightningsplit" + "-" + req.query.channel, splitData);
              saveWellKnownSplit(req.query.channel,splitData); 
            } catch {
              console.log ("⚡️⚡️failed to store lightning split",req.query.channel,splitData);
            } 
            return res.status(200).send(splitData);
          } else {
            console.log("⚡️⚡️lightning address in channel description does not resolve", foundLightningAddress);
          }
        } else {
          console.log("⚡️⚡️no lightning address found in channel description");
        }
        return res.status(400).send();
      }
    }
    console.log("⚡️⚡️unable to lookup split info for", req.query);
    return res.status(400).send();
  })
  router.use('/addsplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️add split called\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send();
    }
    var storedSplitData;
    var split = new Array();
    var newAddress = req.query.splitaddress;
    var newSplit = req.query.split;
    var channel = req.query.channel
    var name = req.query.name;
    var customKey = req.query.customkey;
    var customValue = req.query.customvalue;
    var node = req.query.node;
    var customKeysend = req.query.customkeysend;
    var video = req.query.video;
    if (video) {
      try {
        storedSplitData = await storageManager.getData("lightningsplit" + "-" + video);
      } catch {
        console.log ("⚡️⚡️failed to get lightning split for video",video);
      } 
      console.log("⚡️⚡️retrieved split info for video ", video, "\n", storedSplitData);
      if (!storedSplitData) {
        console.log("⚡️⚡️stored split data not found");
        if (video) {
          console.log("⚡️⚡️base", base);
          var apiCall = base + "/api/v1/videos/" + video;
          console.log("⚡️⚡️ getting video data", apiCall);
          let videoData;
          try {
            videoData = await axios.get(apiCall);
          } catch {
            console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
          }
          if (videoData) {
            console.log("⚡️⚡️channel data",videoData.data.channel);
            if (!channel){
              channel = videoData.data.channel.name;
            }
            storedSplitData = await storageManager.getData("lightningsplit" + "-" + channel);
            //let foundLightningAddress = await findLightningAddress(videoData.data.description + " " + videoData.data.support + " " + videoData.data.channel.description + " " + videoData.data.channel.support + " " + videoData.data.account.description);
            if (storedSplitData) {
              split =storedSplitData;
              /*
              console.log("⚡️⚡️split data found");
              let keysendData = await getKeysendInfo();
              let lnurlData = await getLnurlInfo();
              if (lnurlData || keysendData) {
                let walletData = {};
                walletData.address = foundLightningAddress;
                if (keysendData) {
                  walletData.keysend = keysendData;
                  console.log("⚡️⚡️successfully retrieved keysend data for wallet in video", videoData.data.channel.name, keysendData);
                  //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
                }
                if (lnurlData) {
                  walletData.lnurl = lnurlData;
                  console.log("⚡️⚡️successfully retrieved lnurl data for wallet in video", videoData.data.channel.name, lnurlData);
                  //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

                }
                if (walletData.keysend) {
                  if (walletData.address.indexOf("fountain.fm") > 0) {
                    walletData.keysend = null;
                  }
                }
                var splitData = new Array();
                walletData.split = 100;
                splitData.push(walletData);
                if (hostWalletData && (hostWalletData.split > 1)) {
                  splitData[0].split = 100 - hostWalletData.split;
                }
                splitData.push(hostWalletData);
                //await storageManager.storeData("lightningsplit" + "-" + req.query.video, splitData);
                return res.status(200).send(splitData);
              } else {
                console.log("⚡️⚡️lightning address in video description does not resolve", foundLightningAddress);
              }
              */
            } else {
              console.log("⚡️⚡️no lightning address found in video description");
            }
          }
        }

      } else {
        split = storedSplitData;
      }
    } else if (req.query.channel) {
      try {
        storedSplitData = await storageManager.getData("lightningsplit" + "-" + req.query.channel);
      } catch {
        console.log ("⚡️⚡️failed to get lightning split",req.query.channel);
      } 
        if (storedSplitData) {
        console.log("⚡️⚡️add split retrieved chaNNEL split info", req.query.channel, "\n", storedSplitData.length);
        split = storedSplitData;

      } else {
        console.log("⚡️⚡️no stored split, unable to add", req.query);
        return res.status(400).send();
      }
    }
    console.log("⚡️⚡️⚡️⚡️ got split",channel,video,split);
    if (!split){
      console.log("⚡️⚡️Unable to add split", req.query);
      return res.status(400).send();
    }
    console.log("⚡️⚡️split", split);
    console.log("⚡️⚡️Attempt to add new address [" + newAddress + ']', customKeysend);
    let walletData = { "keysend": { "tag": "keysend", "customData": [{}] } };
    if (newAddress) {
      walletData.address = newAddress;
    } else {
      walletData.address = "custom"
    }
    if (name) {
      walletData.name = name;
    } else {
      walletData.name = "anon";
    }
    if (newSplit) {
      walletData.split = parseInt(newSplit);
    }
    if (customKeysend) {
      walletData.customKeysend = true;
      if (node) {
        walletData.keysend.pubkey = node;
      }

      if (customKey) {
        walletData.keysend.customData[0].customKey = customKey;
        //  split[slot].customKeysend = true;
      }
      if (customValue) {
        walletData.keysend.customData[0].customValue = customValue;
        //   split[slot].customKeysend = true;
      }
      console.log("⚡️⚡️ setup custom wallet", walletData);
    } else {
      let keysendData = await getKeysendInfo(newAddress);
      let lnurlData = await getLnurlInfo(newAddress);
      if (lnurlData || keysendData) {
        if (keysendData) {
          walletData.keysend = keysendData;
          console.log("⚡️⚡️no walletsuccessfully retrieved keysend data for wallet in channel", channel, keysendData);
          //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
        } else {
          console.log("⚡️⚡️no keysend info")
        }
        if (lnurlData) {
          walletData.lnurl = lnurlData;
          console.log("⚡️⚡️successfully retrieved lnurl data for wallet in channel", channel, lnurlData);
          //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
        } else {
          console.log("⚡️⚡️no keysend info")
        }
      } else {
        console.log("⚡️⚡️no wallet data retured for address", newAddress);
        return res.status(404).send();
      }
      console.log("⚡️⚡️ wallet", walletData);
    }
    //var splitData = new Array;
    split.push(walletData);
    let otherSplit = 0
    for (i = 1; i < split.length; i++) {
      console.log("⚡️⚡️split", i, split[i]);
      if (parseInt(split[i].split) < 1) {
        split[i] = 1;
      }
      otherSplit = otherSplit + split[i].split;
    }
    console.log("⚡️⚡️othersplit", otherSplit);

    let creatorSplit = split[0].split - newSplit
    split[0].split = parseInt(creatorSplit);
    console.log("⚡️⚡️split about to be written to storage manager", split);
    try {
      if (!req.query.channel && req.query.video){
        storageManager.storeData("lightningsplit" + "-" + req.query.video, split);  
      } else {
        storageManager.storeData("lightningsplit" + "-" + channel, split);
        saveWellKnownSplit(channel,split); 
       
      }
    } catch {
      console.log ("⚡️⚡️failed to store lightning split",channel,split);
    }
     await pingPI(channel);
    return res.status(200).send(split);
  })
  router.use('/updatesplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️updating split info\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send();
    }
    var storedSplitData;
    var split;
    var newAddress = req.query.splitaddress
    var video = req.query.video;
    var newSplit = req.query.split;
    var channel = req.query.channel;
    var slot = req.query.slot;
    var name = req.query.name;
    var customKey = req.query.customkey;
    var customValue = req.query.customvalue;
    var node = req.query.node;
    var customKeysend = req.query.customkeysend;
    if (!slot) {
      return res.status(400).send();
    }
    if (video && !channel) {
      try {
       storedSplitData = await storageManager.getData("lightningsplit" + "-" + video);
      } catch {
        console.log ("⚡️⚡️failed to GET lightning split",video);
      } 
      console.log("⚡️⚡️retrieved split info for video ", video, "\n", storedSplitData);
      if (!storedSplitData) {
        console.log("⚡️⚡️stored split data for video not found");
        console.log("⚡️⚡️base", base);
        var apiCall = base + "/api/v1/videos/" + video;
        console.log("⚡️⚡️ getting video data", apiCall);
        let videoData;
        try {
          videoData = await axios.get(apiCall);
        } catch {
          console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
          return res.status(400).send();
        }
        if (videoData && !channel) {
          console.log("⚡️⚡️getting channel split instead", videoData.data.channel.name);
          channel = videoData.data.channel.name;

        } else {
          console.log("⚡️⚡️failed to find video data", apiCall);
          return res.status(400).send();
        }
      } else {
        split = storedSplitData;
      }
    }
    if (channel && !split) {
      try {
        split = await storageManager.getData("lightningsplit" + "-" + channel);
      } catch {
        console.log ("⚡️⚡️failed to get lightning split",channel);
      }
      console.log("⚡️⚡️retrieved chaNNEL split info", channel, "\n", split);
    }
    console.log("⚡️⚡️retrieved split info", split);
    if (split){ 
      //TODO may need to relook at this
      if (!customKeysend) {
        keysendData = await getKeysendInfo(newAddress);
      }
      //let lnurlData = await getLnurlInfo(newAddress);
      console.log(`⚡️⚡️updating from`, split[slot]);
      if (newAddress) {
        split[slot].address = newAddress;
      }
      if (newSplit) {
        split[slot].split = parseInt(newSplit);
      }
      if (customKeysend) {
        console.log("⚡️⚡️custom keysend enabled")
        split[slot].customKeysend = true;
        if (node) {
          split[slot].keysend.pubkey = node;
          //split[slot].customKeysend = true;
        }
        if (!split[slot].keysend.customData){
          split[slot].keysend.customData=[{}];
        }
        if (customKey != split[slot].keysend.customData[0].customKey) {
          split[slot].keysend.customData[0].customKey = customKey;
          //  split[slot].customKeysend = true;
        }
        if (customValue != split[slot].keysend.customData[0].customValue) {
          split[slot].keysend.customData[0].customValue = customValue;
          //   split[slot].customKeysend = true;
        }
      } else {
        console.log("⚡️⚡️regular lightning address keysend");
        split[slot].keysend = keysendData;
        split[slot].customKeysend = false;
      }
      console.log("⚡️⚡️customs ",split[slot].keysend,split[slot].keysend.customData);
      if (name) {
        split[slot].name = name;
      }

      //split[slot].keysend = keysendData;
      //split[slot].lnurl = lnurlData;
      let otherSplit = 0;
      for (i = 1; i < split.length; i++) {
        console.log("⚡️⚡️split", i, split[i].split, split[i].address);
        if (parseInt(split[i].split) < 1) {
          split[i].split = 11
        }
        otherSplit = otherSplit + parseInt(split[i].split);
      }
      console.log("⚡️⚡️othersplit", otherSplit);
      let creatorSplit = 100 - otherSplit
      split[0].split = parseInt(creatorSplit);
      console.log("⚡️⚡️ split",split);
      try {
        if (req.query.channel) {
          await storageManager.storeData("lightningsplit" + "-" + channel, split);
          saveWellKnownSplit(channel,split); 
        }
        if (req.query.video) {
          await storageManager.storeData("lightningsplit" + "-" + req.query.video, split);
        }
      } catch {
        console.log ("⚡️⚡️failed to store lightning split",req.query.video,channel,split);
      }
      console.log("⚡️⚡️updated slot", slot, "with", split[slot]);
      //saveWellKnownSplit(channel,split); 
      if (channel){
        await pingPI(channel);
      }
      return res.status(200).send(split)
    }
    return res.status(400).send();
  })
  router.use('/removesplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️removing split info\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send();
    }
    var storedSplitData;
    var split;
    var slot = req.query.slot;
    var channel = req.query.channel;
    var video = req.query.video;
    if (!slot) {
      return res.status(400).send();
    }
    if (req.query.video) {
      try {
        storedSplitData = await storageManager.getData("lightningsplit" + "-" + req.query.video);
      } catch {
        console.log ("⚡️⚡️failed to get lightning split",req.query.video);
      } 
      var apiCall;
      console.log("⚡️⚡️retrieved split info", req.query.key, "\n", storedSplitData);
      if (!storedSplitData) {
        console.log("⚡️⚡️stored split data for video not found");
        if (req.query.video) {
          console.log("⚡️⚡️base", base);
          apiCall = base + "/api/v1/videos/" + req.query.video;
          console.log("⚡️⚡️ getting video data", apiCall);
          let videoData;
          try {
            videoData = await axios.get(apiCall);
          } catch {
            console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
          }
          if (videoData) {
            console.log("⚡️⚡️video channel data",videoData.data.channel);
            channel = videoData.data.channel
          }
        }
 
      } else {
        split = storedSplitData;
      }
    } 
    if (channel) {
      try {
        split = await storageManager.getData("lightningsplit" + "-" + channel);
      } catch {
        console.log ("⚡️⚡️failed to get lightning split for channel",channel);
      } 
      console.log("⚡️⚡️retrieved chaNNEL split info", channel, "\n", split);
    }
    if (split) {
      console.log(`⚡️⚡️removing`, split[slot].address, " of ", split.length, " from ", channel);
      let otherSplit = 0
      let newSplit = new Array();
      for (i = 0; i < split.length; i++) {
        console.log("⚡️⚡️split", i, "of ", split.length, split[i].address);
        if (i == slot) {
          console.log("⚡️⚡️skipping", i)
        } else {
          newSplit.push(split[i]);
          if (i > 0) {
            otherSplit = otherSplit + split[i].split;
          }
        }
      }
      console.log("⚡️⚡️othersplit", otherSplit);
      let creatorSplit = 100 - otherSplit
      newSplit[0].split = parseInt(creatorSplit);
      console.log("⚡️⚡️split about to be writ",video, newSplit.length);
      try {
        if (req.query.channel) {
          await storageManager.storeData("lightningsplit" + "-" + channel, newSplit);
          saveWellKnownSplit(channel,split); 
        }
        if (req.query.video) {
          await storageManager.storeData("lightningsplit" + "-" + video, newSplit);
        }
      } catch (err){
        console.log ("⚡️⚡️failed to store lightning split",channel,newSplit,err);
      } 
        console.log("⚡️⚡️⚡️⚡️ slot removed", slot, ".", newSplit.length, "splits remaining");
      await pingPI(channel);
      return res.status(200).send(newSplit);
    } else {
      console.log("⚡️⚡️stored split data not found");
      //TODO check channel owner account for wallet info
      return res.status(400).send();
    }
  })
  router.use('/getversion', async (req, res) => {
    return res.status(200).send(version);
  })
  router.use('/createsplit', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️creating split info\n", req.query)
    }
    if (!enableKeysend && !enableLnurl) {
      return res.status(503).send();
    }
    var storedSplitData;
    var split = new Array();
    var newAddress = req.query.splitaddress;
    var newSplit = req.query.split;
    var channel = req.query.channel
    var name = req.query.name;
    if (req.query.video) {
      try {
        storedSplitData = await storageManager.getData("lightningsplit" + "-" + req.query.video);
      } catch {
        console.log ("⚡️⚡️failed to get lightning split",req.query.video);
      } 
        console.log("⚡️⚡️retrieved video split info", req.query.key, "\n", storedSplitData);
      if (!storedSplitData) {
        console.log("⚡️⚡️stored video split data not found");
        if (req.query.video) {
          console.log("⚡️⚡️base", base);
          var apiCall = base + "/api/v1/videos/" + req.query.video;
          console.log("⚡️⚡️ getting video data", apiCall);
          let videoData;
          try {
            videoData = await axios.get(apiCall);
          } catch {
            console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
          }
          if (videoData) {
            console.log("⚡️⚡️video channel data",videoData.data.channel);
            let foundLightningAddress = await findLightningAddress(videoData.data.description + " " + videoData.data.support + " " + videoData.data.channel.description + " " + videoData.data.channel.support + " " + videoData.data.account.description);
            if (foundLightningAddress) {
              console.log("⚡️⚡️lightning address found in video description [" + foundLightningAddress + ']');
              let keysendData = await getKeysendInfo(foundLightningAddress);
              let lnurlData = await getLnurlInfo(foundLightningAddress);
              if (lnurlData || keysendData) {
                let walletData = {};
                walletData.address = foundLightningAddress;
                if (keysendData) {
                  walletData.keysend = keysendData;
                  console.log("⚡️⚡️successfully retrieved keysend data for wallet in video", videoData.data.channel.name, keysendData);
                  //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
                }
                if (lnurlData) {
                  walletData.lnurl = lnurlData;
                  console.log("⚡️⚡️successfully retrieved lnurl data for wallet in video", videoData.data.channel.name, lnurlData);
                  //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

                }
                var splitData = new Array();
                walletData.split = 100;
                if (name) {
                  walletData.name = name;
                } else {
                  walletData.name = "anon";
                }
                splitData.push(walletData);
                if (hostWalletData && parseInt(hostwalletData.split) > 0) {
                  splitData[0].split = 100 - hostWalletData.split;
                }
                splitData.push(hostWalletData);
                //await storageManager.storeData("lightningsplit" + "-" + req.query.video, splitData);
                return res.status(200).send(splitData);
              } else {
                console.log("⚡️⚡️lightning address in video description does not resolve", foundLightningAddress);
              }
            } else {
              console.log("⚡️⚡️no lightning address found in video description");
            }
          }
        }
        console.log("⚡️⚡️Unable to add split", req.query);
        return res.status(400).send();

      } else {
        split = storedSplitData;
      }
    } else if (req.query.channel) {
      if (newAddress.length === 66){

      }
      try {
       storedSplitData = await storageManager.getData("lightningsplit" + "-" + req.query.channel);
      } catch {
        console.log ("⚡️⚡️failed to get lightning split",req.query.channel);
      } 
      if (storedSplitData) {
        console.log("⚡️⚡️add split retrieved chaNNEL split info", req.query.channel, "\n", storedSplitData.length);
        console.log('⚡️⚡️already existing splitData for', req.query.channel, storedSplitData);
        return res.status(400).send();
      } else {
        console.log("⚡️⚡️stored split data not found, generating channel split data", req.query.channel);
        //return res.status(400).send();
      }
    }
    console.log("⚡️⚡️split", split);
    console.log("⚡️⚡️Create split attempting to add new address [" + newAddress.length + ']', req.query);
    let keysendData,lnurlData;

    if (newAddress.length === 66){
     keysendData={pubkey:newAddress};
     keysendData.customData = [];
     newAddress="custom";
    } else {
      if (newAddress.indexOf("@")<0){
        console.log("⚡️⚡️malformed address without @");
        return res.status(400).send();
      }
      keysendData = await getKeysendInfo(newAddress);
      lnurlData = await getLnurlInfo(newAddress);
    }
    let walletData = {};
    if (lnurlData || keysendData) {
      walletData.address = newAddress;
      walletData.split = 100;
      if (keysendData) {
        walletData.keysend = keysendData;
        console.log("⚡️⚡️successfully retrieved keysend data for wallet in channel", channel, keysendData);
        //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);
      }
      if (lnurlData) {
        walletData.lnurl = lnurlData;
        console.log("⚡️⚡️successfully retrieved lnurl data for wallet in channel", channel, lnurlData);
        //storageManager.storeData("lightning" + "-" + videoData.data.channel.name, videoLightning);

      }
      //var splitData = new Array;
      if (name){
      walletData.name = name;
      } else {
        walletData.name = newAddress;
      }
      split.push(walletData);
      if (hostWalletData && hostWalletData.split > 0) {
        split[0].split = 100 - hostWalletData.split;
        split.push(hostWalletData);
      } else {
        split[0].split = 100;
      }
      try {
        storageManager.storeData("lightningsplit" + "-" + channel, split);
        saveWellKnownSplit(channel,split); 
      } catch {
        console.log ("⚡️⚡️failed to store lightning split",channel,split);
      } 
      await pingPI(channel);
      return res.status(200).send(split);
    } else {
      console.log("⚡️⚡️lightning address in channel description does not resolve", newAddress);
      return res.status(400).send("Lightning address failed to resolve");
    }
    return res.status(400).send("failed to update");
  })
  router.use('/callback', async (req, res) => {
    console.log("\n⚡️⚡️\n callback",req.query,req.body);

    let state;
    if (req.query.state){
      state = await storageManager.getData("alby-" + req.query.state.replace(/\./g, "-"));
      console.log("\n⚡️⚡️\ncurrent wallet value",state,req.query.state);
    }
    if (state == 'pending'){
      var formFull = new URLSearchParams();
      //formFull = new FormData();
      formFull.append('code', req.query.code);
      formFull.append('grant_type', 'authorization_code');
      formFull.append('redirect_uri', 'https://p2ptube.us/plugins/lightning/router/callback');
      formFull.append('client_id',client_id);
      formFull.append('client_secret',client_secret);
      
      let url = "https://api.getalby.com/oauth/token";
      let response;
      try {
        response = await axios.post(url,formFull,{ auth: { username: client_id, password: client_secret}});
      } catch (err){
        console.log("\n⚡️⚡️⚡️⚡️axios failed to post to alby",err,url,formFull)
      }
      if (response && response.data){
        console.log("\n⚡️⚡️⚡️⚡️response to token request axios",response.data);
        storageManager.storeData("alby-" + req.query.state.replace(/\./g, "-"),response.data);
        let albyToken = response.data.access_token
        let albyWalletData
        let headers = { headers: {"Authorization" : `Bearer `+albyToken} }
        let walletApiUrl="https://api.getalby.com/user/me"
        try {
          
         albyWalletData=await axios.get(walletApiUrl,headers)
        } catch (err) {
          console.log("\n⚡️⚡️⚡️⚡️error attempting to get wallet data\n",walletApiUrl,headers,err);
        }
        console.log("\n⚡️⚡️⚡️⚡️wallet data:\n",albyWalletData);
      }
    }
    return res.status(200).send("User authorized to boost");
    /*
    var chatID = req.query.id;
    console.log("\n\nchatID", chatID);
    var user = {};
    if (!botChats.includes(chatID)) {
      botChats.push(chatID);
      await storageManager.storeData("telegram-chats", botChats);
      console.log("added chat id " + chatID + " to existing telegram users")
    }
    try {
      user = await storageManager.getData(chatID)
      console.log("user data loaded", user);
    } catch (err) {
      console.log("error loading user data", err);
    }
    var userChannels = "";
    if (user) {
      //upgrade hacks
      console.log("existing user detected");
      if (user.muteAnnouncements == undefined) { user.muteAnnouncements = false }
      if (user.muteLives == undefined) { user.muteLives = false }
      if (user.muteSubscriptions == undefined) { user.muteSubscriptions = false }
      if (user.muteWelcome == undefined) { user.muteWelcome = false }
      if (user.pending) { user.pending = undefined }
      if (user.pending2) { user.pending = undefined }
      await storageManager.storeData(user.id, user);
      if (botChats == undefined) {
        console.log("need to initialize botchats");
        botChats = [user.id];

      }
      console.log("\n\nStored telegram user info", user);
      javascriptisstupid = user.id;
      console.log(javascriptisstupid, "welcome back to peertube " + user.displayname);
      if (!user.muteWelcome) {
        sendTelegram(javascriptisstupid, "welcome back to peertube " + user.displayname);
      }
      if (user.avatar != req.query.photo_url) {
        user.avatar = req.query.photo_url;
        console.log("need to update avatar url for user", user.avatar);
        await storageManager.storeData(user.id, user);
      }
      console.log("getting user channels for ", user.username);
      console.log(`/api/v1/accounts/${user.username}/video-channels`)
      try {
        userChannels = await axios.get(`${instance}/api/v1/accounts/${user.username}/video-channels`);
        console.log("User channels loaded during authentication ", userChannels);
        for (const channel of userChannels.data.data) {
          console.log("channel name:", channel.name, "\ndisplay name", channel.displayName, channel.sync);
        }
      } catch (err) { console.log("failed load user channels", user, err) }
    } else {
      user = {};
      console.log("Building new user", req.query);
      var displayname = req.query.username;
      console.log("first try at username", req.query.username);
      if (displayname == undefined) {
        displayname = req.query.first_name + "." + req.query.last_name;
        console.log("fixed username", displayname);
      }
      if (displayname == ".") {
        displayname = req.query.id;
      }
      console.log("displayname: ", displayname);
      user.displayname = displayname;
      user.id = req.query.id;
      user.username = displayname.toLowerCase().replace(/[^\w\s]|_/g, "").replace(/\s+/g, ".");
      user.role = 2;
      user.email = user.username + `@telegram.com`
      user.avatar = req.query.photo_url;
      user.muteAnnouncements = await settingsManager.getSetting("telegram-default-announcements");
      user.muteLives = await settingsManager.getSetting("telegram-default-lives");
      user.muteSubscriptions = await settingsManager.getSetting("telegram-default-subscriptions");
      user.muteWelcome = await settingsManager.getSetting("telegram-default-welcome");
      console.log("saving new user", user);
      await storageManager.storeData(user.id, user);
      await sendTelegram(chatID, instance + "/a/" + user.username);
      // if (user.avatar != undefined) {
      // console.log("attempting to download avatar", user.avatar);
      // avatar = await axios.get(user.avatar);
    }
    console.log("pre-authentication user returned", user, user.id, user.username, user.email, user.role);
    return result.userAuthenticated({
      req,
      res,
      username: user.username,
      email: user.email,
      role: user.role,
      displayName: user.displayname,
    });
    */
  })
  router.use('/setauthorizedwallet', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting authorized wallet", req.query);
    }
    let userName;
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues) {
      if (enableDebug){
         console.log("⚡️⚡️ got authorized peertube user",user.dataValues.username);
      }
      userName = user.dataValues.username;
    } else {
      console.log("⚡️⚡️ not a valid user");
      return res.status(200).send("not a logged in PeerTube user ("+req.query+") ["+user+")");
    }
    if (req.query.clear){
      storageManager.storeData("alby-" + userName.replace(/\./g, "-"),"cleared");
      console.log("⚡️⚡️cleared",userName);
    } else {
      storageManager.storeData("alby-" + userName.replace(/\./g, "-"),"pending");
      console.log("⚡️⚡️set",userName,"to pending");
    }
    return res.status(200).send(true);
  })
  router.use('/checkauthorizedwallet', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️checking authorized wallet", req.query);
    }
    let userName;
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues) {
      userName = user.dataValues.username;
    } else {
      console.log("⚡️⚡️no user found");
      return res.status(420).send();
    }
    let albyData = await storageManager.getData("alby-" + userName.replace(/\./g, "-"));
    console.log("⚡️⚡️stored data", albyData);
    if (albyData && albyData.access_token){
      return res.status(200).send(true);
    } else {
      console.log("failed to get alby data",albyData);
      return res.status(420).send(false);
    }
  })
  router.use('/sendalbypayment', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️sending payment", req.query,req.body);
    }
    let userName;
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues) {
      userName = user.dataValues.username;
    } else {
      console.log("⚡️⚡️no user found");
      return res.status(420).send();
    }
    let albyData = await storageManager.getData("alby-" + userName.replace(/\./g, "-"));
    console.log("⚡️⚡️stored data", albyData);
    if (albyData.access_token){
        let albyToken = albyData.access_token
        let albyWalletData
        let headers = { headers: {"Authorization" : `Bearer `+albyToken} }
        let walletApiUrl="https://api.getalby.com/payments/keysend"
        let data = req.body;
        console.log("-=--=-=-=-=-",data,headers,walletApiUrl)
        try {
          albyWalletData=await axios.post(walletApiUrl,data,headers)
        } catch (err) {
          console.log("\n⚡️⚡️⚡️⚡️error attempting to send boost\n",err.response.status);
          albyWalletData = err.response.status;
        }
        if (albyWalletData == 401){
          console.log("need to refresh token!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
          let albyUrl = 'https://api.getalby.com/oauth/token'
          var form = new URLSearchParams();
          form.append('refresh_token', albyData.refresh_token);
          form.append('grant_type',"refresh_token");
          let headers = { auth: { username: client_id, password: client_secret}};
          let response;
          try {
            response = await axios.post(albyUrl,form,headers);
          } catch (err){
            console.log("\n⚡️⚡️⚡️⚡️axios failed to refresh alby token",err,url,formFull)
          }
          if (response && response.data){
            console.log("\n⚡️⚡️⚡️⚡️response to token refreshrequest axios",response.data);
            storageManager.storeData("alby-" + userName.replace(/\./g, "-"),response.data);
          }
        }
      return res.status(200).send(true);
    } else {
      return res.status(420).send(false);
    }
  })
  router.use('/enablewebhook', async (req, res) => {
    let albyHook="https://api.getalby.com/webhook_endpoints"
    let body ={};
    body.description = "super chat invoices";
    body.url='https://p2ptube.us/plugins/matrixchat/router/v4vchat';
    body.filter_types = ["invoice.incoming.settled"]
    let albyData = await storageManager.getData("alby-don");
    let response;
    console.log("⚡️⚡️stored data", albyData);
    if (albyData && albyData.access_token){
        let albyToken = albyData.access_token
        let albyWalletData
        let headers = { headers: {"Authorization" : `Bearer `+albyToken} }
        console.log("⚡️⚡️⚡️⚡️",body,headers,albyHook)
        try {
          response  = albyWalletData=await axios.post(albyHook,body,headers)
        } catch (err) {
          console.log("\n⚡️⚡️⚡️⚡️error attempting to set webhook\n",err);
          albyWalletData = err.response.status;
        }
        console.log('⚡️⚡️⚡️⚡️ response',response,albyWalletData);
        if (albyWalletData == 401){
          console.log("need to refresh token!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
          let albyUrl = 'https://api.getalby.com/oauth/token'
          var form = new URLSearchParams();
          form.append('refresh_token', albyData.refresh_token);
          form.append('grant_type',"refresh_token");
          let headers = { auth: { username: client_id, password: client_secret}};
          let response;
        try {
            response  = albyWalletData=await axios.post(albyUrl,body,headers)
          } catch (err) {
            console.log("\n⚡️⚡️⚡️⚡️error attempting to set webhook\n",err);
            albyWalletData = err;
          }
          if (response && response.data){
            console.log("\n⚡️⚡️⚡️⚡️response to token refreshrequest axios",response.data);
            storageManager.storeData("alby-" + userName.replace(/\./g, "-"),response.data);
          }
        }





    }

  })
  async function pingPI(pingChannel) {
    let feedApi = base + "/plugins/lightning/router/getfeedid?channel=" + pingChannel;
    let feedId;
    try {
      feedId = await axios.get(feedApi);
      let pingResult;
      if (feedId){
        pingResult = await axios.get("https://api.podcastindex.org/api/1.0/hub/pubnotify?id=" + feedId.data);
      }
      if (pingResult && pingResult.data){
        return (pingResult.data);
      }
    } catch {
      console.log("⚡️⚡️hard error when trying ping podcast index ", feedId,feedApi);
    }
  }
  async function getKeysendInfo(address) {
    if (enableDebug) {
      console.log("⚡️⚡️getting keysend info for", address);
    }
    if (!address) { return };
    //TODO need proper function to validate actor address and derived index value
    if ((address.indexOf(`"`)>=0) || (address.indexOf(">")>=0) || (address.indexOf("<")>=0)){
      return;
    }
    let parts = address.split("@");
    if ((parts.length<2) || (parts[1].indexOf(".")<1)){
      return;
    }  
    var storageIndex = "lightning-" + address.replace(/\./g, "-");
    console.log("⚡️⚡️Getting Address", address, storageIndex);
    var storedLightning;
    try {
     storedLightning = await storageManager.getData(storageIndex);
    } catch {
      console.log ("⚡️⚡️failed to get stored lighting address",storageIndex);
    }
    if (storedLightning) {
      console.log("⚡️⚡️returning stored lightning address", storageIndex);
      //saveWellKnown(parts[0],storedLightning);
      return storedLightning;
    } else {
      console.log("⚡️⚡️no stored data", storageIndex, storedLightning)
    }
    console.log("⚡️⚡️ getting wallet data", address);
    address = address.toString();
    let walletParts = address.split("@");
    let walletHost = walletParts[1];
    let walletUser = walletParts[0];
    let apiRequest = "https://" + walletHost + "/.well-known/keysend/" + walletUser
    console.log("⚡️⚡️requesting wallet data from provider", apiRequest);
    let walletData;
    try {
      walletData = await axios.get(apiRequest);
    } catch (err) {
      console.log("⚡️⚡️ error attempting to get wallet info", apiRequest, err.message)
      return;
    }
    if (walletData.data.status != "OK") {
      console.log("⚡️⚡️ Error in lightning address data", walletData.data);
      return;
    }
    walletData.data.cache = Date.now();
    console.log("⚡️⚡️ wallet data",walletData.data)
    let whatHappened;
    try{
      whatHappened = await storageManager.storeData(storageIndex, walletData.data);
      saveWellKnown(parts[0],walletData.data);
    } catch {
      console.log ("⚡️⚡️failed to store lighting address",storageIndex,walletData.data);
    }
    console.log("⚡️⚡️ stored keysend data", whatHappened, storageIndex, walletData.data);

    return walletData.data;
  }
  async function getLnurlInfo(address) {
    if (enableDebug) {
      console.log("⚡️⚡️getting lnurl info", address);
    }
    if (!address) { return };
    address = address.toString();
    let walletParts = address.split("@");
    let walletHost = walletParts[1];
    let walletUser = walletParts[0];
    let apiRequest = "https://" + walletHost + "/.well-known/lnurlp/" + walletUser
    console.log("⚡️⚡️ requesting lnurlp data from provider", apiRequest);
    let walletData;
    try {
      walletData = await axios.get(apiRequest);
    } catch {
      console.log("⚡️⚡️⚡️⚡️error attempting to get lnurlp info", apiRequest)
      return;
    }
    if (!walletData.data.callback) {
      console.log("⚡️⚡️ Error in lightning address data", walletData.data);
      return;
    }
    return walletData.data;
  }
  async function findLightningAddress(textblock) {
    if (!textblock) {
      return;
    }
    text = textblock.toString();
    const match = text.match(
      /((⚡|⚡️):?|lightning:|lnurl:)\s?([\w-.]+@[\w-.]+[.][\w-.]+)/i
    );
    if (match) return match[3];
    const matchAlbyLink = text.match(
      /http(s)?:\/\/(www[.])?getalby\.com\/p\/(\w+)/
    );
    if (matchAlbyLink) {

      return matchAlbyLink[3] + "@getalby.com";
    }
  }
  async function saveWellKnown(account, keySend) {
    //return;
    const folderName = '/var/www/peertube/storage/well-known/keysend/';
    try {
      if (!fs.existsSync(folderName)) {
        fs.mkdirSync(folderName);
      }
    } catch (err) {
      console.error("⚡️⚡️ problem with well known keysend folder", err, account);
    }
    try {
      fs.writeFileSync(folderName + account, JSON.stringify(keySend));
    } catch (err) {
      console.error("⚡️⚡️ trouble saving the keysend info to peertube folder", err, account);
    }
  }
  async function saveWellKnownSplit(account, splits) {
    //return;
    const folderName = '/var/www/peertube/storage/well-known/keysendsplit/';
    let knownSplits=[];
    for (const split of splits){
      let newSplit ={};
      newSplit.name = split.name;
      newSplit.split = split.split;
      newSplit.keysend = split.keysend;
      if (split.fee){
        newSplit.fee = split.fee;
      }
      knownSplits.push(newSplit);
    }
    console.log("⚡️⚡️ new split data", knownSplits,"⚡️⚡️ account:",account,"⚡️⚡️ raw splits",splits);
    try {
      if (!fs.existsSync(folderName)) {
        fs.mkdirSync(folderName);
      }
    } catch (err) {
      console.error("⚡️⚡️ problem with well known keysend split folder", err, account);
    }
    try {
      fs.writeFileSync(folderName + account, JSON.stringify(knownSplits));
    } catch (err) {
      console.error("⚡️⚡️ trouble saving the keysend split info to peertube folder", err, account);
    }
  }
  async function buildFormData(formData, data, parentKey) {
  if (data && typeof data === 'object' && !(data instanceof Date)) {
    Object.keys(data).forEach(key => {
      buildFormData(formData, data[key], parentKey ? `${parentKey}[${key}]` : key);
    });
  } else {
    const value = data == null ? '' : data;

    formData.append(parentKey, value);
  }
  }

  function jsonToFormData(data) {
  const formData = new URLSearchParams();
  
  buildFormData(formData, data);
  
  return formData;
  }
}
async function unregister() {
  return
}
module.exports = {
  register,
  unregister
}

